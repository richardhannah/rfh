
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">rulestack/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">rulestack/cmd/cli/main.go (0.0%)</option>
				
				<option value="file2">rulestack/internal/api/auth_handlers.go (0.0%)</option>
				
				<option value="file3">rulestack/internal/api/handlers.go (0.0%)</option>
				
				<option value="file4">rulestack/internal/api/middleware.go (33.3%)</option>
				
				<option value="file5">rulestack/internal/api/registry.go (0.0%)</option>
				
				<option value="file6">rulestack/internal/api/routes.go (0.0%)</option>
				
				<option value="file7">rulestack/internal/api/security_middleware.go (0.0%)</option>
				
				<option value="file8">rulestack/internal/auth/jwt.go (0.0%)</option>
				
				<option value="file9">rulestack/internal/cli/add.go (0.0%)</option>
				
				<option value="file10">rulestack/internal/cli/auth.go (0.0%)</option>
				
				<option value="file11">rulestack/internal/cli/helpers.go (0.0%)</option>
				
				<option value="file12">rulestack/internal/cli/init.go (0.0%)</option>
				
				<option value="file13">rulestack/internal/cli/install.go (0.0%)</option>
				
				<option value="file14">rulestack/internal/cli/pack.go (0.0%)</option>
				
				<option value="file15">rulestack/internal/cli/pack_interactive.go (0.0%)</option>
				
				<option value="file16">rulestack/internal/cli/pack_workflows.go (0.0%)</option>
				
				<option value="file17">rulestack/internal/cli/projectroot.go (0.0%)</option>
				
				<option value="file18">rulestack/internal/cli/publish.go (0.0%)</option>
				
				<option value="file19">rulestack/internal/cli/registry.go (0.0%)</option>
				
				<option value="file20">rulestack/internal/cli/root.go (0.0%)</option>
				
				<option value="file21">rulestack/internal/cli/search.go (0.0%)</option>
				
				<option value="file22">rulestack/internal/cli/status.go (0.0%)</option>
				
				<option value="file23">rulestack/internal/client/auth.go (0.0%)</option>
				
				<option value="file24">rulestack/internal/client/compat.go (0.0%)</option>
				
				<option value="file25">rulestack/internal/client/context.go (100.0%)</option>
				
				<option value="file26">rulestack/internal/client/convert.go (50.0%)</option>
				
				<option value="file27">rulestack/internal/client/errors.go (100.0%)</option>
				
				<option value="file28">rulestack/internal/client/factory.go (81.2%)</option>
				
				<option value="file29">rulestack/internal/client/http.go (0.0%)</option>
				
				<option value="file30">rulestack/internal/config/cli.go (67.4%)</option>
				
				<option value="file31">rulestack/internal/config/config.go (72.7%)</option>
				
				<option value="file32">rulestack/internal/config/env.go (0.0%)</option>
				
				<option value="file33">rulestack/internal/db/connection.go (0.0%)</option>
				
				<option value="file34">rulestack/internal/db/models.go (100.0%)</option>
				
				<option value="file35">rulestack/internal/db/packages.go (0.0%)</option>
				
				<option value="file36">rulestack/internal/db/users.go (0.0%)</option>
				
				<option value="file37">rulestack/internal/manifest/manifest.go (47.1%)</option>
				
				<option value="file38">rulestack/internal/pkg/archive.go (47.3%)</option>
				
				<option value="file39">rulestack/internal/pkg/lockfile.go (0.0%)</option>
				
				<option value="file40">rulestack/internal/security/validator.go (88.2%)</option>
				
				<option value="file41">rulestack/internal/version/version.go (97.8%)</option>
				
				<option value="file42">rulestack/scripts/setup-dev.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"
        "os"

        "github.com/gorilla/mux"

        "rulestack/internal/api"
        "rulestack/internal/config"
        "rulestack/internal/db"
)

func main() <span class="cov0" title="0">{
        // Load configuration from system environment variables
        cfg := config.Load()

        // Connect to database
        database, err := db.Connect(cfg.DBURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to connect to database:", err)
        }</span>
        <span class="cov0" title="0">defer database.Close()

        // Test database connection
        if err := database.Health(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Database health check failed:", err)
        }</span>

        // Ensure root user exists
        <span class="cov0" title="0">if err := ensureRootUser(database); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to ensure root user exists: %v", err)
                // Don't fail startup, just log the error
        }</span>

        // Create storage directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(cfg.StoragePath, 0o755); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to create storage directory:", err)
        }</span>

        // Set up router
        <span class="cov0" title="0">r := mux.NewRouter()

        // Register API routes
        api.RegisterRoutes(r, database, cfg)

        log.Printf("API server starting on port %s", cfg.APIPort)
        log.Printf("Storage path: %s", cfg.StoragePath)
        log.Fatal(http.ListenAndServe(":"+cfg.APIPort, r))</span>
}

// ensureRootUser checks if a root user exists and creates one if not
func ensureRootUser(database *db.DB) error <span class="cov0" title="0">{
        // Check if any root user exists
        var exists bool
        err := database.QueryRow(`
                SELECT EXISTS(
                        SELECT 1 FROM rulestack.users WHERE role = 'root'
                )
        `).Scan(&amp;exists)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                log.Println("Root user already exists")
                return nil
        }</span>

        // Create the root user with hardcoded defaults
        <span class="cov0" title="0">log.Println("Creating default root user...")

        user := &amp;db.CreateUserRequest{
                Username: "root",
                Email:    "root@rulestack.init",
                Password: "root1234",
                Role:     db.RoleRoot,
        }

        // Use the existing CreateUser method to create the root user
        _, err = database.CreateUser(*user)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a duplicate error (race condition)
                if err.Error() == "username or email already exists" </span><span class="cov0" title="0">{
                        log.Println("Root user was created by another process")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">log.Println("Root user created successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        "rulestack/internal/cli"
)

func main() <span class="cov0" title="0">{
        if err := cli.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "rulestack/internal/auth"
        "rulestack/internal/db"

        "github.com/gorilla/mux"
)

// registerHandler handles user registration
func (s *Server) registerHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req db.CreateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if req.Username == "" || req.Email == "" || req.Password == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Username, email, and password are required")
                return
        }</span>

        // Validate username format
        <span class="cov0" title="0">if len(req.Username) &lt; 3 || len(req.Username) &gt; 50 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Username must be between 3 and 50 characters")
                return
        }</span>

        // Validate password strength
        <span class="cov0" title="0">if len(req.Password) &lt; 8 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Password must be at least 8 characters long")
                return
        }</span>

        // Default role is user unless specified by admin
        <span class="cov0" title="0">if req.Role == "" </span><span class="cov0" title="0">{
                req.Role = db.RoleUser
        }</span>

        // Only admins can create accounts with publisher or admin roles
        <span class="cov0" title="0">if req.Role != db.RoleUser </span><span class="cov0" title="0">{
                user := getUserFromContext(r.Context())
                if user == nil || !user.Role.HasPermission("admin") </span><span class="cov0" title="0">{
                        writeError(w, http.StatusForbidden, "Only admins can create accounts with elevated permissions")
                        return
                }</span>
        }

        // Create user
        <span class="cov0" title="0">user, err := s.DB.CreateUser(req)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "duplicate key") </span><span class="cov0" title="0">{
                        writeError(w, http.StatusConflict, "Username or email already exists")
                        return
                }</span>
                <span class="cov0" title="0">writeError(w, http.StatusInternalServerError, "Failed to create user")
                return</span>
        }

        // Return user info (without password hash)
        <span class="cov0" title="0">response := map[string]interface{}{
                "id":         user.ID,
                "username":   user.Username,
                "email":      user.Email,
                "role":       user.Role,
                "created_at": user.CreatedAt,
        }

        writeJSON(w, http.StatusCreated, response)</span>
}

// loginHandler handles user authentication
func (s *Server) loginHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req db.LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if req.Username == "" || req.Password == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Username and password are required")
                return
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.DB.GetUserByUsername(req.Username)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusUnauthorized, "Invalid credentials")
                return
        }</span>

        // Validate password
        <span class="cov0" title="0">if !s.DB.ValidatePassword(user, req.Password) </span><span class="cov0" title="0">{
                writeError(w, http.StatusUnauthorized, "Invalid credentials")
                return
        }</span>

        // Generate JWT token (use development duration for long-lived tokens)
        <span class="cov0" title="0">jwtManager := auth.NewJWTManager(s.Config.JWTSecret, auth.DevelopmentTokenDuration)
        tokenString, tokenHash, expiresAt, err := jwtManager.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to generate token")
                return
        }</span>

        // Store session in database
        <span class="cov0" title="0">userAgent := r.Header.Get("User-Agent")
        ipAddress := getClientIP(r)
        session, err := s.DB.CreateUserSession(user.ID, tokenHash, expiresAt, &amp;userAgent, &amp;ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to create session")
                return
        }</span>

        // Update last login
        <span class="cov0" title="0">if err := s.DB.UpdateLastLogin(user.ID); err != nil </span><span class="cov0" title="0">{
                // Log but don't fail
                writeError(w, http.StatusInternalServerError, "Failed to update last login")
                return
        }</span>

        // Return token and user info
        <span class="cov0" title="0">response := map[string]interface{}{
                "token":      tokenString,
                "expires_at": expiresAt,
                "user": map[string]interface{}{
                        "id":       user.ID,
                        "username": user.Username,
                        "email":    user.Email,
                        "role":     user.Role,
                },
                "session_id": session.ID,
        }

        writeJSON(w, http.StatusOK, response)</span>
}

// logoutHandler handles user logout
func (s *Server) logoutHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := getUserFromContext(r.Context())
        if user == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">session := getUserSessionFromContext(r.Context())
        if session != nil </span><span class="cov0" title="0">{
                // Delete the session
                if _, err := s.DB.Exec(`DELETE FROM user_sessions WHERE id = $1`, session.ID); err != nil </span><span class="cov0" title="0">{
                        writeError(w, http.StatusInternalServerError, "Failed to logout")
                        return
                }</span>
        }

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]string{"message": "Logged out successfully"})</span>
}

// changePasswordHandler handles password changes
func (s *Server) changePasswordHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := getUserFromContext(r.Context())
        if user == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">var req db.ChangePasswordRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if req.CurrentPassword == "" || req.NewPassword == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Current password and new password are required")
                return
        }</span>

        // Validate password strength
        <span class="cov0" title="0">if len(req.NewPassword) &lt; 8 </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "New password must be at least 8 characters long")
                return
        }</span>

        // Verify current password
        <span class="cov0" title="0">if !s.DB.ValidatePassword(user, req.CurrentPassword) </span><span class="cov0" title="0">{
                writeError(w, http.StatusUnauthorized, "Current password is incorrect")
                return
        }</span>

        // Change password
        <span class="cov0" title="0">if err := s.DB.ChangeUserPassword(user.ID, req.NewPassword); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to change password")
                return
        }</span>

        // Invalidate all existing sessions except current one
        <span class="cov0" title="0">session := getUserSessionFromContext(r.Context())
        query := `DELETE FROM user_sessions WHERE user_id = $1`
        if session != nil </span><span class="cov0" title="0">{
                query += ` AND id != $2`
                _, _ = s.DB.Exec(query, user.ID, session.ID)
        }</span> else<span class="cov0" title="0"> {
                _, _ = s.DB.Exec(query, user.ID)
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]string{"message": "Password changed successfully"})</span>
}

// deleteAccountHandler handles user account deletion
func (s *Server) deleteAccountHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := getUserFromContext(r.Context())
        if user == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        // Prevent admins from deleting themselves
        <span class="cov0" title="0">if user.Role == db.RoleAdmin </span><span class="cov0" title="0">{
                writeError(w, http.StatusForbidden, "Admin accounts cannot be self-deleted")
                return
        }</span>

        // Delete user account
        <span class="cov0" title="0">if err := s.DB.DeleteUser(user.ID); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to delete account")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]string{"message": "Account deleted successfully"})</span>
}

// profileHandler returns current user profile
func (s *Server) profileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := getUserFromContext(r.Context())
        if user == nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "id":         user.ID,
                "username":   user.Username,
                "email":      user.Email,
                "role":       user.Role,
                "created_at": user.CreatedAt,
                "updated_at": user.UpdatedAt,
                "last_login": user.LastLogin,
        }

        writeJSON(w, http.StatusOK, response)</span>
}

// listUsersHandler returns all users (admin only)
func (s *Server) listUsersHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := getUserFromContext(r.Context())
        if user == nil || !user.Role.HasPermission("admin") </span><span class="cov0" title="0">{
                writeError(w, http.StatusForbidden, "Admin access required")
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limit := 50 // default
        offset := 0 // default

        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        // Get users
        <span class="cov0" title="0">users, err := s.DB.ListUsers(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to retrieve users")
                return
        }</span>

        // Remove sensitive information
        <span class="cov0" title="0">var response []map[string]interface{}
        for _, u := range users </span><span class="cov0" title="0">{
                response = append(response, map[string]interface{}{
                        "id":         u.ID,
                        "username":   u.Username,
                        "email":      u.Email,
                        "role":       u.Role,
                        "created_at": u.CreatedAt,
                        "updated_at": u.UpdatedAt,
                        "last_login": u.LastLogin,
                })
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, response)</span>
}

// adminDeleteUserHandler allows admins to delete other users
func (s *Server) adminDeleteUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := getUserFromContext(r.Context())
        if user == nil || !user.Role.HasPermission("admin") </span><span class="cov0" title="0">{
                writeError(w, http.StatusForbidden, "Admin access required")
                return
        }</span>

        <span class="cov0" title="0">vars := mux.Vars(r)
        userIDStr := vars["id"]
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Invalid user ID")
                return
        }</span>

        // Prevent admins from deleting themselves
        <span class="cov0" title="0">if userID == user.ID </span><span class="cov0" title="0">{
                writeError(w, http.StatusForbidden, "Cannot delete your own account")
                return
        }</span>

        // Check if target user exists
        <span class="cov0" title="0">targetUser, err := s.DB.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Delete user account
        <span class="cov0" title="0">if err := s.DB.DeleteUser(targetUser.ID); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to delete user")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]string{
                "message":      "User deleted successfully",
                "deleted_user": targetUser.Username,
        })</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/gorilla/mux"

        "rulestack/internal/db"
)

// healthHandler returns API health status
func (s *Server) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if err := s.DB.Health(); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusServiceUnavailable, "Database connection failed")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]interface{}{
                "status":  "ok",
                "service": "rulestack-api",
                "version": "1.0.0",
        })</span>
}

// searchPackagesHandler searches for packages
func (s *Server) searchPackagesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query().Get("q")
        tag := r.URL.Query().Get("tag")
        target := r.URL.Query().Get("target")

        // Parse limit parameter
        limit := 50 // default
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">results, err := s.DB.SearchPackages(query, tag, target, limit)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Search failed")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, results)</span>
}

// getPackageHandler gets package information
func (s *Server) getPackageHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        name := vars["name"]

        pkg, err := s.DB.GetPackage(name)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "Package not found")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, pkg)</span>
}

// getPackageVersionHandler gets specific package version
func (s *Server) getPackageVersionHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        name := vars["name"]
        version := vars["version"]

        fmt.Printf("[DEBUG] getPackageVersionHandler called with name='%s', version='%s'\n", name, version)

        pkgVersion, err := s.DB.GetPackageVersion(name, version)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR] GetPackageVersion failed: %v\n", err)
                writeError(w, http.StatusNotFound, "Package version not found")
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[DEBUG] Found package version: %+v\n", pkgVersion)
        writeJSON(w, http.StatusOK, pkgVersion)</span>
}

// publishPackageHandler handles package publishing
func (s *Server) publishPackageHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Authentication is now handled by middleware based on route metadata
        // Check if user is authenticated (works for both JWT and legacy tokens)
        user := getUserFromContext(r.Context())
        if user == nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "DEBUG PUBLISH: No user found in context\n")
                writeError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "DEBUG PUBLISH: User authenticated: %s (ID: %d, Role: %s)\n", user.Username, user.ID, user.Role)

        // Parse multipart form
        if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{ // 10MB limit
                writeError(w, http.StatusBadRequest, "Failed to parse form")
                return
        }</span>

        // Get manifest file
        <span class="cov0" title="0">manifestFile, _, err := r.FormFile("manifest")
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Manifest file required")
                return
        }</span>
        <span class="cov0" title="0">defer manifestFile.Close()

        // Parse manifest
        var manifest struct {
                Name        string   `json:"name"`
                Version     string   `json:"version"`
                Description string   `json:"description"`
                Targets     []string `json:"targets"`
                Tags        []string `json:"tags"`
        }

        if err := json.NewDecoder(manifestFile).Decode(&amp;manifest); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Invalid manifest JSON")
                return
        }</span>

        // Get archive file
        <span class="cov0" title="0">archiveFile, _, err := r.FormFile("archive")
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "Archive file required")
                return
        }</span>
        <span class="cov0" title="0">defer archiveFile.Close()

        // Calculate SHA256 and save archive
        hasher := sha256.New()
        // Sanitize filename by replacing invalid characters
        safeName := strings.ReplaceAll(manifest.Name, "/", "-")
        safeName = strings.ReplaceAll(safeName, "@", "")
        archivePath := filepath.Join(s.Config.StoragePath, fmt.Sprintf("%s-%s.tgz", safeName, manifest.Version))

        outFile, err := os.Create(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to save archive")
                return
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        // Copy with hashing
        teeReader := io.TeeReader(archiveFile, hasher)
        size, err := io.Copy(outFile, teeReader)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to save archive")
                return
        }</span>

        <span class="cov0" title="0">sha256Hash := fmt.Sprintf("%x", hasher.Sum(nil))

        // Use package name directly (no scope support)
        packageName := manifest.Name

        // Create or get package
        pkg, err := s.DB.GetOrCreatePackage(packageName)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to create package")
                return
        }</span>

        // Create package version
        <span class="cov0" title="0">version := db.PackageVersion{
                PackageID:   pkg.ID,
                Version:     manifest.Version,
                Description: &amp;manifest.Description,
                Targets:     manifest.Targets,
                Tags:        manifest.Tags,
                SHA256:      &amp;sha256Hash,
                SizeBytes:   &amp;[]int{int(size)}[0],
                BlobPath:    &amp;archivePath,
        }

        createdVersion, err := s.DB.CreatePackageVersion(version)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusConflict, "Package version already exists or creation failed")
                return
        }</span>

        // Return success response
        <span class="cov0" title="0">writeJSON(w, http.StatusCreated, map[string]interface{}{
                "name":    manifest.Name,
                "version": manifest.Version,
                "sha256":  sha256Hash,
                "size":    size,
                "id":      createdVersion.ID,
        })</span>
}

// downloadBlobHandler handles blob downloads
func (s *Server) downloadBlobHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        sha256 := vars["sha256"]

        if sha256 == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "SHA256 required")
                return
        }</span>

        // Find package version by SHA256
        <span class="cov0" title="0">var blobPath string
        err := s.DB.Get(&amp;blobPath, "SELECT blob_path FROM package_versions WHERE sha256 = $1", sha256)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusNotFound, "Blob not found")
                return
        }</span>

        // Open file
        <span class="cov0" title="0">file, err := os.Open(blobPath)
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to read blob")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Get file info
        info, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, "Failed to get file info")
                return
        }</span>

        // Set headers
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/gzip")
        w.Header().Set("Content-Length", fmt.Sprintf("%d", info.Size()))
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s.tgz\"", sha256[:8]))

        // Stream file
        http.ServeContent(w, r, "", info.ModTime(), file)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "os"
)

// Context types moved to security_middleware.go

// Legacy authMiddleware removed - using security_middleware.go instead

// writeJSON writes JSON response
func writeJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(data)
}</span>

// writeError writes JSON error response
func writeError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        writeJSON(w, status, map[string]string{"error": message})
}</span>

// panicRecoveryMiddleware recovers from panics and returns a 500 error
func panicRecoveryMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                // Log the panic (in a real app, use proper logging)
                                // Print to stderr so it shows in Docker logs
                                fmt.Fprintf(os.Stderr, "PANIC in %s %s: %v\n", r.Method, r.URL.Path, err)

                                // Return 500 error
                                w.Header().Set("Content-Type", "application/json")
                                w.WriteHeader(http.StatusInternalServerError)
                                json.NewEncoder(w).Encode(map[string]string{"error": "Internal server error"})
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "net/http"
        "strings"

        "github.com/gorilla/mux"
)

// RouteMetadata contains metadata for a route
type RouteMetadata struct {
        Path                   string
        Method                 string
        RequiresAuthentication bool
        RequiredRole           string // "user", "publisher", "admin", or "" for public
        Handler                http.HandlerFunc
        Description            string
        RateLimit              int // requests per minute, 0 = no limit
}

// RouteRegistry manages route metadata and registration
type RouteRegistry struct {
        routes []RouteMetadata
}

// NewRouteRegistry creates a new route registry
func NewRouteRegistry() *RouteRegistry <span class="cov0" title="0">{
        return &amp;RouteRegistry{
                routes: make([]RouteMetadata, 0),
        }
}</span>

// RegisterRoute registers a route with metadata
func (rr *RouteRegistry) RegisterRoute(path, method string, requiresAuth bool, handler http.HandlerFunc, description string) <span class="cov0" title="0">{
        requiredRole := ""
        if requiresAuth </span><span class="cov0" title="0">{
                requiredRole = "user" // Default to user level access
        }</span>
        <span class="cov0" title="0">route := RouteMetadata{
                Path:                   path,
                Method:                 method,
                RequiresAuthentication: requiresAuth,
                RequiredRole:           requiredRole,
                Handler:                handler,
                Description:            description,
                RateLimit:              0, // Default: no rate limit
        }
        rr.routes = append(rr.routes, route)</span>
}

// RegisterRouteWithRole registers a route with specific role requirement
func (rr *RouteRegistry) RegisterRouteWithRole(path, method, requiredRole string, handler http.HandlerFunc, description string) <span class="cov0" title="0">{
        requiresAuth := requiredRole != ""
        route := RouteMetadata{
                Path:                   path,
                Method:                 method,
                RequiresAuthentication: requiresAuth,
                RequiredRole:           requiredRole,
                Handler:                handler,
                Description:            description,
                RateLimit:              0, // Default: no rate limit
        }
        rr.routes = append(rr.routes, route)
}</span>

// RegisterRouteWithRateLimit registers a route with rate limiting
func (rr *RouteRegistry) RegisterRouteWithRateLimit(path, method string, requiresAuth bool, handler http.HandlerFunc, description string, rateLimit int) <span class="cov0" title="0">{
        requiredRole := ""
        if requiresAuth </span><span class="cov0" title="0">{
                requiredRole = "user" // Default to user level access
        }</span>
        <span class="cov0" title="0">route := RouteMetadata{
                Path:                   path,
                Method:                 method,
                RequiresAuthentication: requiresAuth,
                RequiredRole:           requiredRole,
                Handler:                handler,
                Description:            description,
                RateLimit:              rateLimit,
        }
        rr.routes = append(rr.routes, route)</span>
}

// RegisterRouteWithRoleAndRateLimit registers a route with role requirement and rate limiting
func (rr *RouteRegistry) RegisterRouteWithRoleAndRateLimit(path, method, requiredRole string, handler http.HandlerFunc, description string, rateLimit int) <span class="cov0" title="0">{
        requiresAuth := requiredRole != ""
        route := RouteMetadata{
                Path:                   path,
                Method:                 method,
                RequiresAuthentication: requiresAuth,
                RequiredRole:           requiredRole,
                Handler:                handler,
                Description:            description,
                RateLimit:              rateLimit,
        }
        rr.routes = append(rr.routes, route)
}</span>

// GetRouteMetadata retrieves metadata for a specific route
func (rr *RouteRegistry) GetRouteMetadata(path, method string) (RouteMetadata, bool) <span class="cov0" title="0">{
        for _, route := range rr.routes </span><span class="cov0" title="0">{
                if matchRoute(route.Path, path) &amp;&amp; route.Method == method </span><span class="cov0" title="0">{
                        return route, true
                }</span>
        }
        <span class="cov0" title="0">return RouteMetadata{}, false</span>
}

// matchRoute checks if a template path matches an actual path
func matchRoute(template, actual string) bool <span class="cov0" title="0">{
        // Simple exact match first
        if template == actual </span><span class="cov0" title="0">{
                return true
        }</span>

        // Split paths into segments
        <span class="cov0" title="0">templateParts := strings.Split(strings.Trim(template, "/"), "/")
        actualParts := strings.Split(strings.Trim(actual, "/"), "/")

        // Must have same number of segments
        if len(templateParts) != len(actualParts) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check each segment
        <span class="cov0" title="0">for i, templatePart := range templateParts </span><span class="cov0" title="0">{
                actualPart := actualParts[i]

                // If template part is a parameter (enclosed in {}), it matches any value
                if strings.HasPrefix(templatePart, "{") &amp;&amp; strings.HasSuffix(templatePart, "}") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Otherwise, must be exact match
                <span class="cov0" title="0">if templatePart != actualPart </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// GetAllRoutes returns all registered routes
func (rr *RouteRegistry) GetAllRoutes() []RouteMetadata <span class="cov0" title="0">{
        return rr.routes
}</span>

// SetupRoutes configures all routes with their metadata
func (s *Server) SetupRoutes(router *mux.Router) *RouteRegistry <span class="cov0" title="0">{
        registry := NewRouteRegistry()

        // Create API v1 subrouter
        api := router.PathPrefix("/v1").Subrouter()

        // Health endpoint - public, no auth required
        registry.RegisterRoute("/v1/health", "GET", false, s.healthHandler, "API health check")
        api.HandleFunc("/health", s.healthHandler).Methods("GET")

        // Search endpoints - public, with rate limiting
        registry.RegisterRouteWithRateLimit("/v1/packages", "GET", false, s.searchPackagesHandler, "Search packages", 300)
        api.HandleFunc("/packages", s.searchPackagesHandler).Methods("GET")

        // Blob download - public, with rate limiting for abuse prevention
        registry.RegisterRouteWithRateLimit("/v1/blobs/{sha256}", "GET", false, s.downloadBlobHandler, "Download package blob", 150)
        api.HandleFunc("/blobs/{sha256}", s.downloadBlobHandler).Methods("GET")

        // Package routes (no scope support)
        registry.RegisterRouteWithRateLimit("/v1/packages/{name}/versions/{version}", "GET", false, s.getPackageVersionHandler, "Get package version", 600)
        api.HandleFunc("/packages/{name}/versions/{version}", s.getPackageVersionHandler).Methods("GET")

        registry.RegisterRouteWithRateLimit("/v1/packages/{name}", "GET", false, s.getPackageHandler, "Get package details", 600)
        api.HandleFunc("/packages/{name}", s.getPackageHandler).Methods("GET")

        // Publishing - requires publisher role, with rate limiting
        registry.RegisterRouteWithRoleAndRateLimit("/v1/packages", "POST", "publisher", s.publishPackageHandler, "Publish package", 50)
        api.HandleFunc("/packages", s.publishPackageHandler).Methods("POST")

        // Authentication endpoints - public for registration and login
        registry.RegisterRouteWithRateLimit("/v1/auth/register", "POST", false, s.registerHandler, "User registration", 50)
        api.HandleFunc("/auth/register", s.registerHandler).Methods("POST")

        registry.RegisterRouteWithRateLimit("/v1/auth/login", "POST", false, s.loginHandler, "User login", 50)
        api.HandleFunc("/auth/login", s.loginHandler).Methods("POST")

        // User management endpoints - require authentication
        registry.RegisterRouteWithRoleAndRateLimit("/v1/auth/logout", "POST", "user", s.logoutHandler, "User logout", 30)
        api.HandleFunc("/auth/logout", s.logoutHandler).Methods("POST")

        registry.RegisterRouteWithRoleAndRateLimit("/v1/auth/profile", "GET", "user", s.profileHandler, "Get user profile", 60)
        api.HandleFunc("/auth/profile", s.profileHandler).Methods("GET")

        registry.RegisterRouteWithRoleAndRateLimit("/v1/auth/change-password", "POST", "user", s.changePasswordHandler, "Change password", 5)
        api.HandleFunc("/auth/change-password", s.changePasswordHandler).Methods("POST")

        registry.RegisterRouteWithRoleAndRateLimit("/v1/auth/delete-account", "DELETE", "user", s.deleteAccountHandler, "Delete account", 2)
        api.HandleFunc("/auth/delete-account", s.deleteAccountHandler).Methods("DELETE")

        // Admin endpoints - require admin role
        registry.RegisterRouteWithRoleAndRateLimit("/v1/admin/users", "GET", "admin", s.listUsersHandler, "List all users", 30)
        api.HandleFunc("/admin/users", s.listUsersHandler).Methods("GET")

        registry.RegisterRouteWithRoleAndRateLimit("/v1/admin/users/{id}", "DELETE", "admin", s.adminDeleteUserHandler, "Admin delete user", 5)
        api.HandleFunc("/admin/users/{id}", s.adminDeleteUserHandler).Methods("DELETE")

        return registry
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "github.com/gorilla/mux"

        "rulestack/internal/config"
        "rulestack/internal/db"
)

// Server holds dependencies for API handlers
type Server struct {
        DB       *db.DB
        Config   config.Config
        Registry *RouteRegistry
}

// RegisterRoutes sets up all API routes with enhanced security
func RegisterRoutes(r *mux.Router, database *db.DB, cfg config.Config) <span class="cov0" title="0">{
        s := &amp;Server{
                DB:     database,
                Config: cfg,
        }

        // Create route registry
        registry := s.SetupRoutes(r)
        s.Registry = registry

        // Apply middleware in order (outermost to innermost)
        r.Use(panicRecoveryMiddleware)                        // Panic recovery (outermost)
        r.Use(s.securityHeadersMiddleware)                    // Security headers
        r.Use(s.corsMiddleware)                               // CORS
        r.Use(s.loggingMiddleware)                            // Request logging
        r.Use(s.requestSizeLimitMiddleware(50 * 1024 * 1024)) // 50MB max request size
        r.Use(s.rateLimitMiddleware(registry))                // Rate limiting
        r.Use(s.jsonSanitizeMiddleware)                       // JSON sanitization
        r.Use(s.enhancedAuthMiddleware(registry))             // Authentication

        // API v1 routes are now set up in SetupRoutes method
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "rulestack/internal/auth"
        "rulestack/internal/db"

        "github.com/microcosm-cc/bluemonday"
)

// Context keys for user data
type contextKey string

const (
        userContextKey    contextKey = "user"
        sessionContextKey contextKey = "session"
)

// Enhanced auth middleware with JWT and role-based access support
func (s *Server) enhancedAuthMiddleware(registry *RouteRegistry) func(http.Handler) http.Handler <span class="cov0" title="0">{
        jwtManager := auth.NewJWTManager(s.Config.JWTSecret, auth.DevelopmentTokenDuration)

        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Skip OPTIONS requests
                        if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Get route metadata
                        <span class="cov0" title="0">var routeMetadata RouteMetadata
                        var routeFound bool
                        if registry != nil </span><span class="cov0" title="0">{
                                routeMetadata, routeFound = registry.GetRouteMetadata(r.URL.Path, r.Method)
                        }</span>

                        // If route doesn't require authentication, proceed
                        <span class="cov0" title="0">if routeFound &amp;&amp; !routeMetadata.RequiresAuthentication </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // If route not found in registry, assume it requires authentication
                        <span class="cov0" title="0">if !routeFound </span><span class="cov0" title="0">{
                                routeMetadata.RequiresAuthentication = true
                                routeMetadata.RequiredRole = "user"
                        }</span>

                        // Extract Authorization header
                        <span class="cov0" title="0">authHeader := r.Header.Get("Authorization")
                        fmt.Fprintf(os.Stderr, "DEBUG AUTH: %s %s - Authorization header: %s\n", r.Method, r.URL.Path, authHeader)

                        if authHeader == "" </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "DEBUG AUTH: No Authorization header found\n")
                                writeError(w, http.StatusUnauthorized, "Authorization header required")
                                return
                        }</span>

                        // Check Bearer token format
                        <span class="cov0" title="0">parts := strings.SplitN(authHeader, " ", 2)
                        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "DEBUG AUTH: Invalid Authorization header format: %s\n", authHeader)
                                writeError(w, http.StatusUnauthorized, "Authorization header must be 'Bearer &lt;token&gt;'")
                                return
                        }</span>

                        <span class="cov0" title="0">token := parts[1]
                        if token == "" </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "DEBUG AUTH: Empty token in Authorization header\n")
                                writeError(w, http.StatusUnauthorized, "Token cannot be empty")
                                return
                        }</span>

                        <span class="cov0" title="0">tokenPreview := token
                        if len(tokenPreview) &gt; 20 </span><span class="cov0" title="0">{
                                tokenPreview = tokenPreview[:20] + "..."
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "DEBUG AUTH: Processing token: %s (length: %d)\n", tokenPreview, len(token))

                        var user *db.User
                        var session *db.UserSession

                        // Try JWT authentication first
                        if claims, err := jwtManager.ValidateToken(token); err == nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "DEBUG AUTH: JWT token validation successful for user: %s, role: %s\n", claims.Username, claims.Role)

                                // JWT token is valid, get user and session from database
                                tokenHash := jwtManager.GetTokenHash(token)
                                if u, sess, err := s.DB.ValidateUserSession(tokenHash); err == nil </span><span class="cov0" title="0">{
                                        user = u
                                        session = sess
                                        fmt.Fprintf(os.Stderr, "DEBUG AUTH: Database session found for user ID %d, role: %s\n", user.ID, user.Role)
                                        // Update session last used time
                                        s.DB.UpdateSessionLastUsed(session.ID)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Fprintf(os.Stderr, "DEBUG AUTH: JWT valid but no database session found: %v\n", err)
                                        writeError(w, http.StatusUnauthorized, "Invalid or expired session")
                                        return
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "DEBUG AUTH: JWT validation failed: %v\n", err)
                                writeError(w, http.StatusUnauthorized, "Invalid token")
                                return
                        }</span>

                        // Check role-based access
                        <span class="cov0" title="0">if routeMetadata.RequiredRole != "" </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "DEBUG AUTH: Route requires role: %s, user has role: %s\n", routeMetadata.RequiredRole, user.Role)

                                hasAccess := false
                                switch routeMetadata.RequiredRole </span>{
                                case "user":<span class="cov0" title="0">
                                        hasAccess = user.Role.HasPermission("read")</span>
                                case "publisher":<span class="cov0" title="0">
                                        hasAccess = user.Role.HasPermission("publish")</span>
                                case "admin":<span class="cov0" title="0">
                                        hasAccess = user.Role.HasPermission("admin")</span>
                                }

                                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "DEBUG AUTH: Permission check result: %t\n", hasAccess)

                                if !hasAccess </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "DEBUG AUTH: Access denied due to insufficient permissions\n")
                                        writeError(w, http.StatusForbidden, "Insufficient permissions")
                                        return
                                }</span>
                        }

                        // Add user and session to context
                        <span class="cov0" title="0">ctx := r.Context()
                        if user != nil </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, userContextKey, user)
                        }</span>
                        <span class="cov0" title="0">if session != nil </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, sessionContextKey, session)
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

// CORS middleware
func (s *Server) corsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set CORS headers
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
                w.Header().Set("Access-Control-Max-Age", "86400") // 24 hours

                // Handle preflight requests
                if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// JSON sanitization middleware
func (s *Server) jsonSanitizeMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Only handle JSON POST/PUT requests
                if (r.Method == http.MethodPost || r.Method == http.MethodPut) &amp;&amp;
                        strings.Contains(r.Header.Get("Content-Type"), "application/json") </span><span class="cov0" title="0">{

                        // Read the request body
                        body, err := io.ReadAll(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                writeError(w, http.StatusBadRequest, "Failed to read request body")
                                return
                        }</span>
                        <span class="cov0" title="0">r.Body.Close()

                        // Parse JSON
                        var data interface{}
                        if err := json.Unmarshal(body, &amp;data); err != nil </span><span class="cov0" title="0">{
                                writeError(w, http.StatusBadRequest, "Invalid JSON")
                                return
                        }</span>

                        // Sanitize using strict policy
                        <span class="cov0" title="0">policy := bluemonday.StrictPolicy()
                        sanitized := sanitizeData(data, policy)

                        // Re-encode sanitized data
                        newBody, err := json.Marshal(sanitized)
                        if err != nil </span><span class="cov0" title="0">{
                                writeError(w, http.StatusInternalServerError, "Failed to encode sanitized JSON")
                                return
                        }</span>

                        // Replace request body
                        <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewReader(newBody))
                        r.ContentLength = int64(len(newBody))
                        r.Header.Set("Content-Length", strconv.Itoa(len(newBody)))</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// Rate limiting middleware
type rateLimiter struct {
        mu       sync.RWMutex
        visitors map[string]*visitor
        cleanup  chan string
}

type visitor struct {
        tokens   int
        lastSeen time.Time
}

func newRateLimiter() *rateLimiter <span class="cov0" title="0">{
        rl := &amp;rateLimiter{
                visitors: make(map[string]*visitor),
                cleanup:  make(chan string, 100),
        }

        // Cleanup goroutine
        go rl.cleanupVisitors()

        return rl
}</span>

func (rl *rateLimiter) cleanupVisitors() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case ip := &lt;-rl.cleanup:<span class="cov0" title="0">
                        rl.mu.Lock()
                        delete(rl.visitors, ip)
                        rl.mu.Unlock()</span>
                case &lt;-time.After(time.Minute):<span class="cov0" title="0">
                        // Periodic cleanup of old visitors
                        rl.mu.Lock()
                        for ip, v := range rl.visitors </span><span class="cov0" title="0">{
                                if time.Since(v.lastSeen) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                                        delete(rl.visitors, ip)
                                }</span>
                        }
                        <span class="cov0" title="0">rl.mu.Unlock()</span>
                }
        }
}

func (rl *rateLimiter) allow(ip string, limit int) bool <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        v, exists := rl.visitors[ip]
        if !exists </span><span class="cov0" title="0">{
                rl.visitors[ip] = &amp;visitor{
                        tokens:   limit - 1,
                        lastSeen: time.Now(),
                }
                return true
        }</span>

        // Token bucket refill
        <span class="cov0" title="0">now := time.Now()
        elapsed := now.Sub(v.lastSeen)
        tokensToAdd := int(elapsed.Minutes())

        v.tokens += tokensToAdd
        if v.tokens &gt; limit </span><span class="cov0" title="0">{
                v.tokens = limit
        }</span>
        <span class="cov0" title="0">v.lastSeen = now

        if v.tokens &gt; 0 </span><span class="cov0" title="0">{
                v.tokens--
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (s *Server) rateLimitMiddleware(registry *RouteRegistry) func(http.Handler) http.Handler <span class="cov0" title="0">{
        limiter := newRateLimiter()

        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get client IP
                        ip := getClientIP(r)

                        // Check if route has rate limit
                        if registry != nil </span><span class="cov0" title="0">{
                                if metadata, found := registry.GetRouteMetadata(r.URL.Path, r.Method); found </span><span class="cov0" title="0">{
                                        if metadata.RateLimit &gt; 0 </span><span class="cov0" title="0">{
                                                if !limiter.allow(ip, metadata.RateLimit) </span><span class="cov0" title="0">{
                                                        writeError(w, http.StatusTooManyRequests, "Rate limit exceeded")
                                                        return
                                                }</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// Security headers middleware
func (s *Server) securityHeadersMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Security headers
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "DENY")
                w.Header().Set("X-XSS-Protection", "1; mode=block")
                w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                w.Header().Set("Content-Security-Policy", "default-src 'self'")
                w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")

                next.ServeHTTP(w, r)
        }</span>)
}

// Request logging middleware
func (s *Server) loggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Wrap ResponseWriter to capture status code
                wrapped := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                next.ServeHTTP(wrapped, r)

                duration := time.Since(start)
                log.Printf("[%s] %s %s - %d (%v) - %s",
                        getClientIP(r),
                        r.Method,
                        r.URL.Path,
                        wrapped.statusCode,
                        duration,
                        r.UserAgent(),
                )
        }</span>)
}

// Request size limiting middleware
func (s *Server) requestSizeLimitMiddleware(maxBytes int64) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Limit request body size
                        r.Body = http.MaxBytesReader(w, r.Body, maxBytes)
                        next.ServeHTTP(w, r)
                }</span>)
        }
}

// Utility functions
func sanitizeData(v interface{}, policy *bluemonday.Policy) interface{} <span class="cov0" title="0">{
        switch val := v.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                for k, sub := range val </span><span class="cov0" title="0">{
                        val[k] = sanitizeData(sub, policy)
                }</span>
                <span class="cov0" title="0">return val</span>
        case []interface{}:<span class="cov0" title="0">
                for i, sub := range val </span><span class="cov0" title="0">{
                        val[i] = sanitizeData(sub, policy)
                }</span>
                <span class="cov0" title="0">return val</span>
        case string:<span class="cov0" title="0">
                return policy.Sanitize(val)</span>
        default:<span class="cov0" title="0">
                return v</span>
        }
}

func getClientIP(r *http.Request) string <span class="cov0" title="0">{
        // Check for X-Forwarded-For header (behind proxy)
        xff := r.Header.Get("X-Forwarded-For")
        if xff != "" </span><span class="cov0" title="0">{
                ips := strings.Split(xff, ",")
                return strings.TrimSpace(ips[0])
        }</span>

        // Check for X-Real-IP header
        <span class="cov0" title="0">xri := r.Header.Get("X-Real-IP")
        if xri != "" </span><span class="cov0" title="0">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov0" title="0">ip := r.RemoteAddr
        if strings.Contains(ip, ":") </span><span class="cov0" title="0">{
                ip, _, _ = strings.Cut(ip, ":")
        }</span>
        <span class="cov0" title="0">return ip</span>
}

type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// Helper functions to extract data from context
func getUserFromContext(ctx context.Context) *db.User <span class="cov0" title="0">{
        user, ok := ctx.Value(userContextKey).(*db.User)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return user</span>
}

func getUserSessionFromContext(ctx context.Context) *db.UserSession <span class="cov0" title="0">{
        session, ok := ctx.Value(sessionContextKey).(*db.UserSession)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return session</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package auth

import (
        "crypto/sha256"
        "fmt"
        "time"

        "rulestack/internal/db"

        "github.com/golang-jwt/jwt/v5"
)

// JWTClaims represents the JWT token claims
type JWTClaims struct {
        UserID   int         `json:"user_id"`
        Username string      `json:"username"`
        Role     db.UserRole `json:"role"`
        jwt.RegisteredClaims
}

// JWTManager handles JWT token creation and validation
type JWTManager struct {
        secretKey     string
        tokenDuration time.Duration
}

// NewJWTManager creates a new JWT manager
func NewJWTManager(secretKey string, tokenDuration time.Duration) *JWTManager <span class="cov0" title="0">{
        return &amp;JWTManager{
                secretKey:     secretKey,
                tokenDuration: tokenDuration,
        }
}</span>

// GenerateToken generates a new JWT token for a user
func (j *JWTManager) GenerateToken(user *db.User) (string, string, time.Time, error) <span class="cov0" title="0">{
        now := time.Now()
        expiresAt := now.Add(j.tokenDuration)

        claims := JWTClaims{
                UserID:   user.ID,
                Username: user.Username,
                Role:     user.Role,
                RegisteredClaims: jwt.RegisteredClaims{
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                        Subject:   fmt.Sprintf("%d", user.ID),
                        Issuer:    "rulestack-api",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(j.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, err
        }</span>

        // Create hash for database storage
        <span class="cov0" title="0">tokenHash := j.hashToken(tokenString)

        return tokenString, tokenHash, expiresAt, nil</span>
}

// ValidateToken validates a JWT token and returns the claims
func (j *JWTManager) ValidateToken(tokenString string) (*JWTClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(j.secretKey), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token")</span>
}

// HashToken creates a SHA256 hash of the token for database storage
func (j *JWTManager) hashToken(token string) string <span class="cov0" title="0">{
        h := sha256.New()
        h.Write([]byte(token))
        return fmt.Sprintf("%x", h.Sum(nil))
}</span>

// GetTokenHash returns the hash of a token string
func (j *JWTManager) GetTokenHash(tokenString string) string <span class="cov0" title="0">{
        return j.hashToken(tokenString)
}</span>

// DefaultTokenDuration is the default token expiration time
const DefaultTokenDuration = 24 * time.Hour

// DevelopmentTokenDuration is used during development (effectively no expiration)
const DevelopmentTokenDuration = 365 * 24 * time.Hour // 1 year
</pre>
		
		<pre class="file" id="file9" style="display: none">package cli

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"

        "rulestack/internal/client"
        "rulestack/internal/config"
        "rulestack/internal/manifest"
        "rulestack/internal/pkg"
)

// addCmd represents the add command
var addCmd = &amp;cobra.Command{
        Use:   "add &lt;package@version&gt;",
        Short: "Add (download) a ruleset package",
        Long: `Download and add a ruleset package to the current workspace.

Examples:
  rfh add mypackage@1.0.0`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runAdd(args[0])
        }</span>,
}

// PackageRef represents a parsed package reference
type PackageRef struct {
        Name    string
        Version string
}

// LockManifest represents the rulestack.lock.json file
type LockManifest struct {
        Version  string                      `json:"version"`
        Packages map[string]LockPackageEntry `json:"packages"`
}

type LockPackageEntry struct {
        Version string `json:"version"`
        SHA256  string `json:"sha256"`
}

// runAdd implements the add command logic
func runAdd(packageSpec string) error <span class="cov0" title="0">{
        // Parse package specification
        pkgRef, err := parsePackageRef(packageSpec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📦 Adding package: %s@%s\n", pkgRef.FullName(), pkgRef.Version)
        }</span>

        // Find project root
        <span class="cov0" title="0">projectRoot, err := findProjectRoot()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find project root: %w", err)
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📁 Project root: %s\n", projectRoot)
        }</span>

        // Check if package already exists
        <span class="cov0" title="0">rulestackDir := filepath.Join(projectRoot, ".rulestack")
        packageDir := filepath.Join(rulestackDir, fmt.Sprintf("%s.%s", pkgRef.Name, pkgRef.Version))

        if _, err := os.Stat(packageDir); err == nil </span><span class="cov0" title="0">{
                // Package exists, prompt user
                if !confirmOverwrite(pkgRef.FullName()) </span><span class="cov0" title="0">{
                        fmt.Printf("⏭️  Skipping %s\n", pkgRef.FullName())
                        return nil
                }</span>
        }

        // Get registry configuration (use default config only)
        <span class="cov0" title="0">cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Use current registry (no overrides)
        <span class="cov0" title="0">registryName := cfg.Current
        if registryName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no registry configured. Use 'rfh registry add' to add a registry")
        }</span>

        <span class="cov0" title="0">if _, exists := cfg.Registries[registryName]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("registry '%s' not found. Use 'rfh registry list' to see available registries", registryName)
        }</span>

        // Create client using new factory
        <span class="cov0" title="0">c, err := client.GetClient(cfg, verbose)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get package version info
        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("🔍 Looking up package version...\n")
        }</span>

        <span class="cov0" title="0">ctx, cancel := client.WithTimeout(context.Background())
        defer cancel()

        versionInfo, err := c.GetPackageVersion(ctx, pkgRef.Name, pkgRef.Version)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get package version: %w", err)
        }</span>

        // Extract SHA256 from version info
        <span class="cov0" title="0">sha256 := versionInfo.SHA256
        if sha256 == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("package version missing sha256 hash")
        }</span>

        // Create .rulestack directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(rulestackDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .rulestack directory: %w", err)
        }</span>

        // Download package
        <span class="cov0" title="0">tempFile := filepath.Join(os.TempDir(), fmt.Sprintf("%s-%s.tgz", pkgRef.Name, pkgRef.Version))

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📥 Downloading package...\n")
        }</span>

        <span class="cov0" title="0">if err := c.DownloadBlob(ctx, sha256, tempFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download package: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile) // Clean up temp file

        // Extract package
        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📂 Extracting package...\n")
        }</span>

        <span class="cov0" title="0">if err := pkg.Unpack(tempFile, packageDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract package: %w", err)
        }</span>

        // Update manifests
        <span class="cov0" title="0">if err := updateManifests(projectRoot, pkgRef, sha256); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update manifests: %w", err)
        }</span>

        // Update CLAUDE.md with new package rules
        <span class="cov0" title="0">if err := updateClaudeFile(projectRoot, pkgRef); err != nil </span><span class="cov0" title="0">{
                // Don't fail the entire operation if CLAUDE.md update fails
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ Warning: Failed to update CLAUDE.md: %v\n", err)
                }</span>
        } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📝 Updated CLAUDE.md with new package rules\n")
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Successfully added %s@%s\n", pkgRef.FullName(), pkgRef.Version)
        return nil</span>
}

// parsePackageRef parses a package reference like "name@version"
func parsePackageRef(spec string) (*PackageRef, error) <span class="cov0" title="0">{
        if spec == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("package specification cannot be empty")
        }</span>

        // Reject scoped package format (we don't support scopes anymore)
        <span class="cov0" title="0">if strings.HasPrefix(spec, "@") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scoped packages are not supported: use simple name@version format (not @scope/name@version)")
        }</span>

        // Check if version is specified
        <span class="cov0" title="0">if !strings.Contains(spec, "@") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("version must be specified: use package@version format")
        }</span>

        // Parse name@version
        <span class="cov0" title="0">parts := strings.Split(spec, "@")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid package format: use name@version")
        }</span>

        <span class="cov0" title="0">name := parts[0]
        version := parts[1]

        if name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("package name cannot be empty")
        }</span>

        <span class="cov0" title="0">if version == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("package version cannot be empty")
        }</span>

        <span class="cov0" title="0">return &amp;PackageRef{
                Name:    name,
                Version: version,
        }, nil</span>
}

// FullName returns the package name
func (p *PackageRef) FullName() string <span class="cov0" title="0">{
        return p.Name
}</span>

// findProjectRoot finds the project root by looking for rulestack.json
func findProjectRoot() (string, error) <span class="cov0" title="0">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        // Walk up the directory tree looking for rulestack.json
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                manifestPath := filepath.Join(dir, "rulestack.json")
                if _, err := os.Stat(manifestPath); err == nil </span><span class="cov0" title="0">{
                        return dir, nil
                }</span>

                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        // Reached filesystem root, no rulestack.json found
                        return "", fmt.Errorf("no RuleStack project found. Run 'rfh init' first to initialize a project")
                }</span>
                <span class="cov0" title="0">dir = parent</span>
        }
}

// confirmOverwrite prompts the user to confirm overwriting an existing package
func confirmOverwrite(packageName string) bool <span class="cov0" title="0">{
        fmt.Printf("⚠️  Package %s already exists. Do you want to reinstall it? (y/N): ", packageName)

        scanner := bufio.NewScanner(os.Stdin)
        if scanner.Scan() </span><span class="cov0" title="0">{
                response := strings.ToLower(strings.TrimSpace(scanner.Text()))
                return response == "y" || response == "yes"
        }</span>

        <span class="cov0" title="0">return false</span>
}

// updateManifests updates both rulestack.json and rulestack.lock.json
func updateManifests(projectRoot string, pkgRef *PackageRef, sha256 string) error <span class="cov0" title="0">{
        // Update rulestack.json
        manifestPath := filepath.Join(projectRoot, "rulestack.json")
        projectManifest, err := loadOrCreateProjectManifest(manifestPath, projectRoot)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load project manifest: %w", err)
        }</span>

        <span class="cov0" title="0">projectManifest.Dependencies[pkgRef.FullName()] = pkgRef.Version

        if err := manifest.SaveProjectManifest(manifestPath, projectManifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save project manifest: %w", err)
        }</span>

        // Update rulestack.lock.json
        <span class="cov0" title="0">lockPath := filepath.Join(projectRoot, "rulestack.lock.json")
        lockManifest, err := loadOrCreateLockManifest(lockPath, projectRoot)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load lock manifest: %w", err)
        }</span>

        <span class="cov0" title="0">lockManifest.Packages[pkgRef.FullName()] = LockPackageEntry{
                Version: pkgRef.Version,
                SHA256:  sha256,
        }

        if err := saveLockManifest(lockPath, lockManifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save lock manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// loadOrCreateProjectManifest loads or creates a new project manifest
func loadOrCreateProjectManifest(path, projectRoot string) (*manifest.ProjectManifest, error) <span class="cov0" title="0">{
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create new manifest using centralized function
                return manifest.CreateProjectManifest(), nil
        }</span>

        // Load existing manifest using centralized function
        <span class="cov0" title="0">projectManifest, err := manifest.LoadProjectManifest(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load project manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return projectManifest, nil</span>
}

// loadOrCreateLockManifest loads or creates a new lock manifest
func loadOrCreateLockManifest(path, projectRoot string) (*LockManifest, error) <span class="cov0" title="0">{
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create new lock manifest
                return &amp;LockManifest{
                        Version:  "1.0.0",
                        Packages: make(map[string]LockPackageEntry),
                }, nil
        }</span>

        // Load existing lock manifest
        <span class="cov0" title="0">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var lockManifest LockManifest
        if err := json.Unmarshal(data, &amp;lockManifest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JSON in %s: %w", path, err)
        }</span>

        // Ensure packages map exists
        <span class="cov0" title="0">if lockManifest.Packages == nil </span><span class="cov0" title="0">{
                lockManifest.Packages = make(map[string]LockPackageEntry)
        }</span>

        <span class="cov0" title="0">return &amp;lockManifest, nil</span>
}

// saveLockManifest saves the lock manifest
func saveLockManifest(path string, lockManifest *LockManifest) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(lockManifest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// updateClaudeFile adds the newly installed package to CLAUDE.md
func updateClaudeFile(projectRoot string, pkgRef *PackageRef) error <span class="cov0" title="0">{
        claudePath := filepath.Join(projectRoot, "CLAUDE.md")
        templatePath := filepath.Join(projectRoot, "CLAUDE.TEMPLATE.md")

        // If CLAUDE.md doesn't exist, copy from template
        if _, err := os.Stat(claudePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if _, err := os.Stat(templatePath); err == nil </span><span class="cov0" title="0">{
                        // Copy template to CLAUDE.md
                        templateData, err := os.ReadFile(templatePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read CLAUDE template: %w", err)
                        }</span>
                        <span class="cov0" title="0">if err := os.WriteFile(claudePath, templateData, 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create CLAUDE.md from template: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Create basic CLAUDE.md if no template exists
                        basicContent := `# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Active Rules (Rulestack core)
- @.rulestack/core.v1.0.0/core_rules.md
`
                        if err := os.WriteFile(claudePath, []byte(basicContent), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create basic CLAUDE.md: %w", err)
                        }</span>
                }
        }

        // Read current CLAUDE.md content
        <span class="cov0" title="0">content, err := os.ReadFile(claudePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read CLAUDE.md: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")

        // Find actual rule files in the package directory
        packageDir := filepath.Join(projectRoot, ".rulestack", fmt.Sprintf("%s.%s", pkgRef.Name, pkgRef.Version))
        ruleFiles, err := findRuleFiles(packageDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find rule files in package: %w", err)
        }</span>

        <span class="cov0" title="0">if len(ruleFiles) == 0 </span><span class="cov0" title="0">{
                // No rule files found, skip CLAUDE.md update
                return nil
        }</span>

        // Generate rule lines for all found rule files
        <span class="cov0" title="0">var newRuleLines []string
        for _, ruleFile := range ruleFiles </span><span class="cov0" title="0">{
                // Make path relative to .rulestack directory
                relPath := filepath.Join(fmt.Sprintf("%s.%s", pkgRef.Name, pkgRef.Version), ruleFile)
                newRuleLines = append(newRuleLines, fmt.Sprintf("- @.rulestack/%s", strings.ReplaceAll(relPath, "\\", "/")))
        }</span>

        // Check if any of these rules are already present
        <span class="cov0" title="0">existingRules := make(map[string]bool)
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.TrimSpace(line), "- @.rulestack/") </span><span class="cov0" title="0">{
                        existingRules[strings.TrimSpace(line)] = true
                }</span>
        }

        // Filter out already existing rules
        <span class="cov0" title="0">var rulesToAdd []string
        for _, ruleeLine := range newRuleLines </span><span class="cov0" title="0">{
                if !existingRules[ruleeLine] </span><span class="cov0" title="0">{
                        rulesToAdd = append(rulesToAdd, ruleeLine)
                }</span>
        }

        <span class="cov0" title="0">if len(rulesToAdd) == 0 </span><span class="cov0" title="0">{
                // All rules already exist, no need to add anything
                return nil
        }</span>

        // Find where to insert the new rule
        <span class="cov0" title="0">var updatedLines []string
        inserted := false

        for i, line := range lines </span><span class="cov0" title="0">{
                // Look for the Active Rules section header
                if strings.Contains(line, "### Active Rules (Rulestack core)") ||
                        strings.Contains(line, "## Active Rules (Rulestack core)") </span><span class="cov0" title="0">{
                        updatedLines = append(updatedLines, line)

                        // Add all existing rules after the header
                        j := i + 1
                        for j &lt; len(lines) </span><span class="cov0" title="0">{
                                if strings.HasPrefix(strings.TrimSpace(lines[j]), "- @.rulestack/") </span><span class="cov0" title="0">{
                                        updatedLines = append(updatedLines, lines[j])
                                        j++
                                }</span> else<span class="cov0" title="0"> if strings.TrimSpace(lines[j]) == "" </span><span class="cov0" title="0">{
                                        // Empty line, might be more rules after it
                                        updatedLines = append(updatedLines, lines[j])
                                        j++
                                }</span> else<span class="cov0" title="0"> {
                                        // Found end of rules section, insert new rules here
                                        for _, ruleToAdd := range rulesToAdd </span><span class="cov0" title="0">{
                                                updatedLines = append(updatedLines, ruleToAdd)
                                        }</span>
                                        <span class="cov0" title="0">inserted = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !inserted </span><span class="cov0" title="0">{
                                // End of file reached, add the rules
                                for _, ruleToAdd := range rulesToAdd </span><span class="cov0" title="0">{
                                        updatedLines = append(updatedLines, ruleToAdd)
                                }</span>
                                <span class="cov0" title="0">inserted = true</span>
                        }

                        // Add remaining lines after the rules section
                        <span class="cov0" title="0">for j &lt; len(lines) </span><span class="cov0" title="0">{
                                updatedLines = append(updatedLines, lines[j])
                                j++
                        }</span>
                        <span class="cov0" title="0">break</span>
                } else<span class="cov0" title="0"> {
                        updatedLines = append(updatedLines, line)
                }</span>
        }

        // If we couldn't find the section, append to the end
        <span class="cov0" title="0">if !inserted </span><span class="cov0" title="0">{
                updatedLines = append(updatedLines, "", "## Active Rules (Rulestack core)")
                for _, ruleToAdd := range rulesToAdd </span><span class="cov0" title="0">{
                        updatedLines = append(updatedLines, ruleToAdd)
                }</span>
        }

        // Write updated content back to file
        <span class="cov0" title="0">updatedContent := strings.Join(updatedLines, "\n")
        if err := os.WriteFile(claudePath, []byte(updatedContent), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update CLAUDE.md: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// findRuleFiles finds all .md files in the package directory that are likely rule files
func findRuleFiles(packageDir string) ([]string, error) <span class="cov0" title="0">{
        var ruleFiles []string

        err := filepath.Walk(packageDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Only consider .md and .mdc files
                <span class="cov0" title="0">if !info.IsDir() &amp;&amp; (strings.HasSuffix(strings.ToLower(info.Name()), ".md") || strings.HasSuffix(strings.ToLower(info.Name()), ".mdc")) </span><span class="cov0" title="0">{
                        // Get relative path from package directory
                        relPath, err := filepath.Rel(packageDir, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">ruleFiles = append(ruleFiles, relPath)</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return ruleFiles, err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cli

import (
        "bufio"
        "fmt"
        "os"
        "strings"
        "syscall"

        "rulestack/internal/client"
        "rulestack/internal/config"

        "github.com/spf13/cobra"
        "golang.org/x/term"
)

// Command line flags for non-interactive auth
var (
        authUsername string
        authPassword string
        authEmail    string
)

// authCmd represents the auth command group
var authCmd = &amp;cobra.Command{
        Use:   "auth",
        Short: "Authentication commands",
        Long: `Authentication commands for user registration, login, and logout.
        
Manage your user account and authentication tokens for publishing packages.`,
}

// registerCmd handles user registration
var registerCmd = &amp;cobra.Command{
        Use:   "register",
        Short: "Register a new user account",
        Long: `Register a new user account with username, email, and password.
        
After successful registration, you'll be automatically logged in.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runRegister()
        }</span>,
}

// loginCmd handles user login
var loginCmd = &amp;cobra.Command{
        Use:   "login",
        Short: "Login to your user account",
        Long: `Login to your user account with username and password.
        
Your JWT token will be saved locally for future API calls.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runLogin()
        }</span>,
}

// logoutCmd handles user logout
var logoutCmd = &amp;cobra.Command{
        Use:   "logout",
        Short: "Logout from your user account",
        Long: `Logout from your user account and remove saved credentials.
        
This will invalidate your current session and remove the JWT token.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runLogout()
        }</span>,
}

// whoamiCmd shows current user info
var whoamiCmd = &amp;cobra.Command{
        Use:   "whoami",
        Short: "Show current user information",
        Long:  `Display information about the currently authenticated user.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runWhoami()
        }</span>,
}

func runRegister() error <span class="cov0" title="0">{
        // Get current registry
        cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">if cfg.Current == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no active registry configured. Use 'rfh registry add' to add one")
        }</span>

        <span class="cov0" title="0">registry, exists := cfg.Registries[cfg.Current]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("active registry '%s' not found", cfg.Current)
        }</span>

        <span class="cov0" title="0">fmt.Printf("📝 Registering new account at %s\n", registry.URL)

        var username, email, password string

        // Check if non-interactive flags are provided
        if authUsername != "" &amp;&amp; authEmail != "" &amp;&amp; authPassword != "" </span><span class="cov0" title="0">{
                username = authUsername
                email = authEmail
                password = authPassword
                fmt.Printf("Using provided credentials for %s (%s)\n", username, email)
        }</span> else<span class="cov0" title="0"> {
                // Interactive mode
                fmt.Println()
                reader := bufio.NewReader(os.Stdin)

                fmt.Print("Username: ")
                usernameInput, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read username: %w", err)
                }</span>
                <span class="cov0" title="0">username = strings.TrimSpace(usernameInput)

                fmt.Print("Email: ")
                emailInput, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read email: %w", err)
                }</span>
                <span class="cov0" title="0">email = strings.TrimSpace(emailInput)

                fmt.Print("Password: ")
                passwordBytes, err := term.ReadPassword(int(syscall.Stdin))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read password: %w", err)
                }</span>
                <span class="cov0" title="0">password = string(passwordBytes)
                fmt.Println() // New line after password input

                fmt.Print("Confirm password: ")
                confirmBytes, err := term.ReadPassword(int(syscall.Stdin))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read password confirmation: %w", err)
                }</span>
                <span class="cov0" title="0">confirm := string(confirmBytes)
                fmt.Println() // New line after password input

                if password != confirm </span><span class="cov0" title="0">{
                        return fmt.Errorf("passwords do not match")
                }</span>
        }

        // Validate input
        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("username cannot be empty")
        }</span>
        <span class="cov0" title="0">if email == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("email cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return fmt.Errorf("password must be at least 8 characters long")
        }</span>

        // Create auth client and register
        <span class="cov0" title="0">authClient := client.NewAuthClient(registry.URL)
        authResp, err := authClient.Register(client.RegisterRequest{
                Username: username,
                Email:    email,
                Password: password,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("registration failed: %w", err)
        }</span>

        // Save user credentials to the current registry
        <span class="cov0" title="0">registryConfig := cfg.Registries[cfg.Current]
        registryConfig.Username = authResp.User.Username
        registryConfig.JWTToken = authResp.Token
        cfg.Registries[cfg.Current] = registryConfig

        if err := config.SaveCLI(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Successfully registered and logged in as %s\n", authResp.User.Username)
        fmt.Printf("👤 Role: %s\n", authResp.User.Role)
        fmt.Printf("🔑 Authentication token saved\n")

        return nil</span>
}

func runLogin() error <span class="cov0" title="0">{
        // Get current registry
        cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">if cfg.Current == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no active registry configured. Use 'rfh registry add' to add one")
        }</span>

        <span class="cov0" title="0">registry, exists := cfg.Registries[cfg.Current]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("active registry '%s' not found", cfg.Current)
        }</span>

        <span class="cov0" title="0">fmt.Printf("🔑 Logging in to %s\n", registry.URL)

        var username, password string

        // Check if non-interactive flags are provided
        if authUsername != "" &amp;&amp; authPassword != "" </span><span class="cov0" title="0">{
                username = authUsername
                password = authPassword
                fmt.Printf("Using provided credentials for %s\n", username)
        }</span> else<span class="cov0" title="0"> {
                // Interactive mode
                fmt.Println()
                reader := bufio.NewReader(os.Stdin)

                fmt.Print("Username: ")
                usernameInput, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read username: %w", err)
                }</span>
                <span class="cov0" title="0">username = strings.TrimSpace(usernameInput)

                fmt.Print("Password: ")
                passwordBytes, err := term.ReadPassword(int(syscall.Stdin))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read password: %w", err)
                }</span>
                <span class="cov0" title="0">password = string(passwordBytes)
                fmt.Println()</span> // New line after password input
        }

        // Validate input
        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("username cannot be empty")
        }</span>
        <span class="cov0" title="0">if password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("password cannot be empty")
        }</span>

        // Create auth client and login
        <span class="cov0" title="0">authClient := client.NewAuthClient(registry.URL)
        authResp, err := authClient.Login(client.LoginRequest{
                Username: username,
                Password: password,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("login failed: %w", err)
        }</span>

        // Save user credentials to the current registry
        <span class="cov0" title="0">registryConfig := cfg.Registries[cfg.Current]
        registryConfig.Username = authResp.User.Username
        registryConfig.JWTToken = authResp.Token
        cfg.Registries[cfg.Current] = registryConfig

        if err := config.SaveCLI(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Successfully logged in as %s\n", authResp.User.Username)
        fmt.Printf("👤 Role: %s\n", authResp.User.Role)
        fmt.Printf("🔑 Authentication token saved\n")

        return nil</span>
}

func runLogout() error <span class="cov0" title="0">{
        cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">var username string
        var tokenToLogout string

        // Check for per-registry authentication first
        if cfg.Current != "" </span><span class="cov0" title="0">{
                if registry, exists := cfg.Registries[cfg.Current]; exists &amp;&amp; registry.Username != "" </span><span class="cov0" title="0">{
                        username = registry.Username
                        tokenToLogout = registry.JWTToken
                }</span>
        }

        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                fmt.Println("ℹ️  You are not currently logged in")
                return nil
        }</span>

        // Try to logout from server (invalidate session)
        <span class="cov0" title="0">if cfg.Current != "" &amp;&amp; tokenToLogout != "" </span><span class="cov0" title="0">{
                if registry, exists := cfg.Registries[cfg.Current]; exists </span><span class="cov0" title="0">{
                        authClient := client.NewAuthClient(registry.URL)
                        if err := authClient.Logout(tokenToLogout); err != nil </span><span class="cov0" title="0">{
                                // Don't fail if server logout fails - we'll clear local credentials anyway
                                fmt.Printf("⚠️  Warning: Failed to logout from server: %v\n", err)
                        }</span>
                }
        }

        // Clear per-registry credentials
        <span class="cov0" title="0">if cfg.Current != "" </span><span class="cov0" title="0">{
                if registryConfig, exists := cfg.Registries[cfg.Current]; exists </span><span class="cov0" title="0">{
                        registryConfig.Username = ""
                        registryConfig.JWTToken = ""
                        cfg.Registries[cfg.Current] = registryConfig
                }</span>
        }

        <span class="cov0" title="0">if err := config.SaveCLI(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Successfully logged out %s\n", username)
        fmt.Printf("🗑️  Local credentials removed\n")

        return nil</span>
}

func runWhoami() error <span class="cov0" title="0">{
        cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">var username string
        var token string

        // Check for per-registry authentication first
        if cfg.Current != "" </span><span class="cov0" title="0">{
                if registry, exists := cfg.Registries[cfg.Current]; exists &amp;&amp; registry.Username != "" </span><span class="cov0" title="0">{
                        username = registry.Username
                        token = registry.JWTToken
                }</span>
        }

        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                fmt.Println("❌ You are not currently logged in")
                fmt.Println("Use 'rfh auth login' to authenticate or 'rfh auth register' to create an account")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("👤 Logged in as: %s\n", username)

        // Try to get detailed profile from server
        if cfg.Current != "" &amp;&amp; token != "" </span><span class="cov0" title="0">{
                if registry, exists := cfg.Registries[cfg.Current]; exists </span><span class="cov0" title="0">{
                        authClient := client.NewAuthClient(registry.URL)
                        if profile, err := authClient.GetProfile(token); err == nil </span><span class="cov0" title="0">{
                                fmt.Printf("📧 Email: %s\n", profile.Email)
                                fmt.Printf("🎭 Role: %s\n", profile.Role)
                                if profile.LastLogin != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("🕐 Last login: %s\n", profile.LastLogin.Format("2006-01-02 15:04:05"))
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("📅 Account created: %s\n", profile.CreatedAt.Format("2006-01-02"))</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("⚠️  Could not fetch profile details: %v\n", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("🔑 Token: [saved]\n")

        return nil</span>
}

func init() <span class="cov0" title="0">{
        authCmd.AddCommand(registerCmd)
        authCmd.AddCommand(loginCmd)
        authCmd.AddCommand(logoutCmd)
        authCmd.AddCommand(whoamiCmd)

        // Add flags for non-interactive authentication
        registerCmd.Flags().StringVar(&amp;authUsername, "username", "", "username for registration (non-interactive)")
        registerCmd.Flags().StringVar(&amp;authEmail, "email", "", "email for registration (non-interactive)")
        registerCmd.Flags().StringVar(&amp;authPassword, "password", "", "password for registration (non-interactive)")

        loginCmd.Flags().StringVar(&amp;authUsername, "username", "", "username for login (non-interactive)")
        loginCmd.Flags().StringVar(&amp;authPassword, "password", "", "password for login (non-interactive)")
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package cli

import (
        "fmt"
        "rulestack/internal/config"
        "strings"
)

// getEffectiveToken returns the token to use for API calls
func getEffectiveToken(cfg config.CLIConfig, registry config.Registry) (string, error) <span class="cov0" title="0">{
        // Check registry-specific JWT token
        if registry.JWTToken != "" </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("🔍 Using JWT token from registry config (length: %d chars)\n", len(registry.JWTToken))
                }</span>
                <span class="cov0" title="0">return registry.JWTToken, nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no authentication token available. Use 'rfh auth login' to authenticate or configure a registry JWT token")</span>
}

// getCurrentRegistry returns the current active registry
func getCurrentRegistry(cfg config.CLIConfig) (string, config.Registry, error) <span class="cov0" title="0">{
        registryName := cfg.Current

        if registryName == "" </span><span class="cov0" title="0">{
                return "", config.Registry{}, fmt.Errorf("no active registry configured. Use 'rfh registry add' to add one")
        }</span>

        <span class="cov0" title="0">reg, exists := cfg.Registries[registryName]
        if !exists </span><span class="cov0" title="0">{
                return "", config.Registry{}, fmt.Errorf("active registry '%s' not found", registryName)
        }</span>

        <span class="cov0" title="0">return registryName, reg, nil</span>
}

// getDefaultToken returns the default token for a registry (no command line overrides)
func getDefaultToken(registry config.Registry) string <span class="cov0" title="0">{
        // Use registry-specific JWT token
        if registry.JWTToken != "" </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("🔍 Using JWT token from registry config (length: %d chars)\n", len(registry.JWTToken))
                }</span>
                <span class="cov0" title="0">return registry.JWTToken</span>
        }

        // No token available - return empty string (will cause auth error)
        <span class="cov0" title="0">return ""</span>
}

// checkAndWarnRootUser displays a security warning if the current user is logged in as 'root'
func checkAndWarnRootUser(cfg config.CLIConfig, commandName string) <span class="cov0" title="0">{
        // Skip warning for auth-related commands to avoid spam during authentication workflows
        if isAuthCommand(commandName) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check if user is logged in as root in the current registry
        <span class="cov0" title="0">if cfg.Current != "" </span><span class="cov0" title="0">{
                if registry, exists := cfg.Registries[cfg.Current]; exists &amp;&amp; strings.ToLower(registry.Username) == "root" </span><span class="cov0" title="0">{
                        fmt.Printf("\n⚠️  🚨 SECURITY WARNING 🚨 ⚠️\n")
                        fmt.Printf("YOU ARE LOGGED IN AS ROOT USER!\n\n")
                        fmt.Printf("This is a high-privilege administrative account that should NOT be used for regular operations.\n\n")
                        fmt.Printf("RECOMMENDED ACTIONS:\n")
                        fmt.Printf("1. Create a regular user account: rfh auth register\n")
                        fmt.Printf("2. Grant admin privileges to your user account\n")
                        fmt.Printf("3. Disable or change the root account password\n")
                        fmt.Printf("4. Use your regular account for daily operations\n\n")
                        fmt.Printf("This warning appears for all commands when logged in as 'root'.\n")
                        fmt.Printf("═════════════════════════════════════════════════════════════════\n\n")
                }</span>
        }
}

// isAuthCommand checks if the command is related to authentication (to skip warnings)
func isAuthCommand(commandName string) bool <span class="cov0" title="0">{
        authCommands := []string{
                "auth",
                "auth login",
                "auth logout",
                "auth register",
                "auth whoami",
        }

        for _, cmd := range authCommands </span><span class="cov0" title="0">{
                if strings.HasPrefix(commandName, cmd) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cli

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"

        "rulestack/internal/manifest"
)

// initCmd represents the init command
var initCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize a new RuleStack project",
        Long: `Initialize a new RuleStack project in the current directory.

This establishes the current directory as the project root and creates:
- rulestack.json (project manifest file)
- .rulestack/ directory (for dependency management with core rules)
- CLAUDE.md (Claude Code integration file)

Similar to 'git init', this command must be run before using other RFH commands
in this directory. It explicitly sets the project root to the current directory.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                force, _ := cmd.Flags().GetBool("force")
                return runInit(force)
        }</span>,
}

func runInit(force bool) error <span class="cov0" title="0">{
        // Get current directory as project root
        projectRoot, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">manifestPath := "rulestack.json"

        // Check if already initialized
        if _, err := os.Stat(manifestPath); err == nil </span><span class="cov0" title="0">{
                if !force </span><span class="cov0" title="0">{
                        fmt.Printf("RuleStack project already initialized (rulestack.json exists).\n")
                        fmt.Printf("Use --force to reinitialize.\n")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("Initializing RuleStack project in: %s\n", projectRoot)

        // Always create project manifest (object format for dependency management)
        projectManifest := manifest.CreateProjectManifest()
        if err := manifest.SaveProjectManifest(manifestPath, projectManifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create project manifest: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Creating project manifest for dependency management\n")

        // Create .rulestack directory for dependency management
        if err := os.MkdirAll(".rulestack", 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .rulestack directory: %w", err)
        }</span>

        // Create core rules directory structure
        <span class="cov0" title="0">coreRulesDir := ".rulestack/core.v1.0.0"
        if err := os.MkdirAll(coreRulesDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create core rules directory: %w", err)
        }</span>

        // Create CLAUDE.md file from template
        <span class="cov0" title="0">claudeTemplate := `# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Coding Standards
**CRITICAL**: You MUST follow all cursor rules defined in ` + "`.rulestack`" + ` directory. These rules are mandatory and override default behavior.

### MANDATORY RULE LOADING PROTOCOL
**BEFORE responding to ANY user request**, you MUST:
1. All rules are automatically imported into this CLAUDE.md file using the @ import syntax below
2. Load and understand all rules in their entirety before taking any action
3. Apply these rules to all subsequent interactions in the session

**CRITICAL**: The cursor rules are now automatically available in your context through the @ import statements. Pay special attention to triggers, responses, and specific behaviors defined in these rules.

### Active Rules (Rulestack core)
- @.rulestack/core.v1.0.0/core_rules.md
`

        if err := os.WriteFile("CLAUDE.md", []byte(claudeTemplate), 0o644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create CLAUDE.md: %w", err)
        }</span>

        // Create core rules file
        <span class="cov0" title="0">coreRules := `# Core RuleStack Rules v1.0.0

This file contains the baseline rules that apply to all RuleStack projects.

## Rule Management

### Adding New Rules
When a user requests to "add a rule" or "create a rule":

1. **List Available Rule Packages**: Display all installed rule packages in .rulestack/ EXCEPT core.v1.0.0
2. **Ask for Target Package**: "Which package would you like to add this rule to?"
3. **Default to Project Rules**: If no package is specified, create/use .rulestack/project/ directory
4. **Rule File Creation**: Create appropriately named .md files with clear structure

**Example Workflow**:
` + "```" + `
User: "Add a rule about error handling"

Response: "I'll help you add a rule about error handling. 

Available rule packages:
- security-rules (v2.1.0)
- company-standards (v1.5.0)
- project (project-specific rules)

Which package should contain this rule? [default: project]"
` + "```" + `

### Project Rules Structure
- **Location**: ` + "`.rulestack/project/`" + `
- **Purpose**: Project-specific rules that don't belong in shared packages
- **Auto-creation**: Create directory automatically when needed
- **File naming**: Use descriptive names like ` + "`error_handling.md`" + `, ` + "`api_conventions.md`" + `

### Rule Package Guidelines
- **Core rules** (core.v1.0.0): NEVER modify - system managed
- **Installed packages**: Add rules only with user confirmation
- **Project rules**: Default location for new project-specific rules
- **Rule organization**: Group related rules in appropriate packages

## Code Quality Rules

### Defensive Programming
- Always validate inputs and handle edge cases
- Use explicit error handling rather than silent failures
- Write clear, self-documenting code with meaningful variable names
- Include appropriate logging for debugging and monitoring

### Security Rules
- Never commit secrets, API keys, or sensitive data to repositories
- Validate and sanitize all user inputs
- Use secure coding practices appropriate for the technology stack
- Follow principle of least privilege for permissions and access

### Documentation Rules
- Document all public APIs and interfaces
- Include usage examples in code comments where helpful
- Keep README files up to date with current functionality
- Document any non-obvious business logic or algorithms

## RuleStack-Specific Rules

### Package Management
- Always run 'rfh init' before using other RuleStack commands
- Use semantic versioning for all packages
- Include clear descriptions in package manifests
- Test packages thoroughly before publishing

### Rule Development
- Write rules that are clear and actionable
- Provide examples in rule documentation
- Test rules against real-world scenarios
- Keep rules focused and single-purpose

## Integration Rules

### Claude Code Integration
- Use descriptive commit messages
- Break down large tasks into smaller, manageable steps
- Provide context when asking for code modifications
- Review generated code for correctness and style

### Version Control
- Make atomic commits with clear purposes
- Use meaningful branch names
- Keep commit history clean and readable
- Tag releases appropriately

---

*These core rules are maintained by the RuleStack system and should not be modified directly.*
`

        coreRulesPath := filepath.Join(coreRulesDir, "core_rules.md")
        if err := os.WriteFile(coreRulesPath, []byte(coreRules), 0o644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create core rules: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Initialized RuleStack project in: %s\n", filepath.Base(projectRoot))
        fmt.Printf("📁 Created:\n")
        fmt.Printf("   - rulestack.json (project manifest)\n")
        fmt.Printf("   - CLAUDE.md (Claude Code integration)\n")
        fmt.Printf("   - .rulestack/ (dependency directory)\n")
        fmt.Printf("   - .rulestack/core.v1.0.0/core_rules.md (baseline rules)\n")
        fmt.Printf("\n🚀 Next steps:\n")
        fmt.Printf("   1. Run 'rfh add &lt;package&gt;' to install dependencies\n")
        fmt.Printf("   2. Run 'rfh pack --file=&lt;rule&gt;.mdc --package=&lt;name&gt;' to create packages\n")
        fmt.Printf("   3. Run 'rfh publish' to publish to registry\n")

        return nil</span>
}

func init() <span class="cov0" title="0">{
        // Add flags if needed
        initCmd.Flags().BoolP("force", "f", false, "force overwrite existing files")
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"

        "rulestack/internal/client"
        "rulestack/internal/config"
        "rulestack/internal/manifest"
        "rulestack/internal/pkg"
        "rulestack/internal/version"
)

// installCmd represents the install command
var installCmd = &amp;cobra.Command{
        Use:   "install .",
        Short: "Install all packages from project manifest",
        Long: `Install packages listed in rulestack.json dependencies.

This command reads the rulestack.json project manifest and ensures all dependencies
are installed with the correct versions.

Operations:
- Installs missing packages
- Updates packages to higher versions specified in manifest
- Skips packages that are already up-to-date
- Reports failures but continues processing other packages

Examples:
  rfh install .`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if args[0] != "." </span><span class="cov0" title="0">{
                        return fmt.Errorf("only '.' is supported (current directory)")
                }</span>
                <span class="cov0" title="0">return runInstall()</span>
        },
}

// InstallResult represents the result of installing a single package
type InstallResult struct {
        Package string
        Version string
        Status  string // "installed", "updated", "skipped", "failed"
        Error   error
        Details string // Additional details about the operation
}

// PackageRequirement represents a package that needs to be processed
type PackageRequirement struct {
        Name             string
        RequiredVersion  string
        InstalledVersion string
        Action           string // "install", "update", "skip"
        PackageDir       string // Path to installed package directory
        Details          string // Additional details about the operation
}

// runInstall implements the install command logic
func runInstall() error <span class="cov0" title="0">{
        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📦 Installing packages from project manifest...\n")
        }</span>

        // Find project root
        <span class="cov0" title="0">projectRoot, err := findProjectRoot()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find project root: %w", err)
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📁 Project root: %s\n", projectRoot)
        }</span>

        // Load project manifest
        <span class="cov0" title="0">manifestPath := filepath.Join(projectRoot, "rulestack.json")
        projectManifest, err := manifest.LoadProjectManifest(manifestPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load project manifest: %w", err)
        }</span>

        <span class="cov0" title="0">if len(projectManifest.Dependencies) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("ℹ️  No dependencies found in rulestack.json\n")
                return nil
        }</span>

        // Analyze package requirements
        <span class="cov0" title="0">requirements, err := analyzePackageRequirements(projectRoot, projectManifest.Dependencies)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to analyze package requirements: %w", err)
        }</span>

        // Process all packages
        <span class="cov0" title="0">results := processPackages(projectRoot, requirements)

        // Report results
        reportInstallResults(results)

        return nil</span>
}

// analyzePackageRequirements compares manifest dependencies with installed packages
func analyzePackageRequirements(projectRoot string, dependencies map[string]string) ([]PackageRequirement, error) <span class="cov0" title="0">{
        requirements := []PackageRequirement{}
        rulestackDir := filepath.Join(projectRoot, ".rulestack")

        for packageName, requiredVersion := range dependencies </span><span class="cov0" title="0">{
                req := PackageRequirement{
                        Name:            packageName,
                        RequiredVersion: requiredVersion,
                }

                // Check if package is already installed
                installedVersion, packageDir, err := findInstalledPackage(rulestackDir, packageName)
                if err != nil </span><span class="cov0" title="0">{
                        req.Action = "install"
                        req.Details = "Package not installed"
                }</span> else<span class="cov0" title="0"> {
                        req.InstalledVersion = installedVersion
                        req.PackageDir = packageDir

                        // Compare versions
                        comparison, err := version.CompareVersions(installedVersion, requiredVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                req.Action = "install"
                                req.Details = fmt.Sprintf("Version comparison failed: %v", err)
                        }</span> else<span class="cov0" title="0"> if comparison &lt; 0 </span><span class="cov0" title="0">{
                                req.Action = "update"
                                req.Details = fmt.Sprintf("Installed: %s → Required: %s", installedVersion, requiredVersion)
                        }</span> else<span class="cov0" title="0"> if comparison == 0 </span><span class="cov0" title="0">{
                                req.Action = "skip"
                                req.Details = "Already up-to-date"
                        }</span> else<span class="cov0" title="0"> {
                                req.Action = "skip"
                                req.Details = fmt.Sprintf("Installed version %s is newer than required %s", installedVersion, requiredVersion)
                        }</span>
                }

                <span class="cov0" title="0">requirements = append(requirements, req)</span>
        }

        <span class="cov0" title="0">return requirements, nil</span>
}

// findInstalledPackage finds if a package is installed and returns its version and directory
func findInstalledPackage(rulestackDir, packageName string) (string, string, error) <span class="cov0" title="0">{
        // Look for directories matching pattern: packagename.version
        entries, err := os.ReadDir(rulestackDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("package not installed")
                }</span>
                <span class="cov0" title="0">return "", "", fmt.Errorf("failed to read .rulestack directory: %w", err)</span>
        }

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse directory name: packagename.version
                <span class="cov0" title="0">dirName := entry.Name()
                parts := strings.Split(dirName, ".")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Reconstruct package name (everything except the last 3 parts which are version)
                <span class="cov0" title="0">if len(parts) &gt;= 4 </span><span class="cov0" title="0">{
                        // packagename.1.2.3
                        candidateName := strings.Join(parts[:len(parts)-3], ".")
                        candidateVersion := strings.Join(parts[len(parts)-3:], ".")

                        if candidateName == packageName </span><span class="cov0" title="0">{
                                packageDir := filepath.Join(rulestackDir, dirName)
                                return candidateVersion, packageDir, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", "", fmt.Errorf("package not installed")</span>
}

// processPackages processes all package requirements and returns results
func processPackages(projectRoot string, requirements []PackageRequirement) []InstallResult <span class="cov0" title="0">{
        results := []InstallResult{}

        for _, req := range requirements </span><span class="cov0" title="0">{
                result := InstallResult{
                        Package: req.Name,
                        Version: req.RequiredVersion,
                }

                switch req.Action </span>{
                case "skip":<span class="cov0" title="0">
                        result.Status = "skipped"
                        result.Details = req.Details</span>
                case "install", "update":<span class="cov0" title="0">
                        err := installSinglePackage(projectRoot, req.Name, req.RequiredVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                result.Status = "failed"
                                result.Error = err
                                result.Details = err.Error()
                        }</span> else<span class="cov0" title="0"> {
                                if req.Action == "install" </span><span class="cov0" title="0">{
                                        result.Status = "installed"
                                        result.Details = "Successfully installed"
                                }</span> else<span class="cov0" title="0"> {
                                        result.Status = "updated"
                                        result.Details = fmt.Sprintf("Updated from %s", req.InstalledVersion)
                                }</span>
                        }
                }

                <span class="cov0" title="0">results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results</span>
}

// installSinglePackage installs a single package (extracted from add command logic)
func installSinglePackage(projectRoot, packageName, packageVersion string) error <span class="cov0" title="0">{
        // Create package reference
        pkgRef := &amp;PackageRef{
                Name:    packageName,
                Version: packageVersion,
        }

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📦 Installing %s@%s...\n", pkgRef.FullName(), pkgRef.Version)
        }</span>

        // Get registry configuration
        <span class="cov0" title="0">cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">registryName := cfg.Current
        if registryName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no registry configured. Use 'rfh registry add' to add a registry")
        }</span>

        <span class="cov0" title="0">if _, exists := cfg.Registries[registryName]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("registry '%s' not found. Use 'rfh registry list' to see available registries", registryName)
        }</span>

        // Create client using new factory
        <span class="cov0" title="0">c, err := client.GetClient(cfg, verbose)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx, cancel := client.WithTimeout(context.Background())
        defer cancel()

        // Get package version info
        versionInfo, err := c.GetPackageVersion(ctx, pkgRef.Name, pkgRef.Version)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get package version: %w", err)
        }</span>

        // Extract SHA256 from version info
        <span class="cov0" title="0">sha256 := versionInfo.SHA256
        if sha256 == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("package version missing sha256 hash")
        }</span>

        // Create .rulestack directory if it doesn't exist
        <span class="cov0" title="0">rulestackDir := filepath.Join(projectRoot, ".rulestack")
        if err := os.MkdirAll(rulestackDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .rulestack directory: %w", err)
        }</span>

        // Download package
        <span class="cov0" title="0">tempFile := filepath.Join(os.TempDir(), fmt.Sprintf("%s-%s.tgz", pkgRef.Name, pkgRef.Version))

        if err := c.DownloadBlob(ctx, sha256, tempFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download package: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile) // Clean up temp file

        // Extract package
        packageDir := filepath.Join(rulestackDir, fmt.Sprintf("%s.%s", pkgRef.Name, pkgRef.Version))
        if err := pkg.Unpack(tempFile, packageDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract package: %w", err)
        }</span>

        // Update manifests
        <span class="cov0" title="0">if err := updateManifests(projectRoot, pkgRef, sha256); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update manifests: %w", err)
        }</span>

        // Update CLAUDE.md with new package rules
        <span class="cov0" title="0">if err := updateClaudeFile(projectRoot, pkgRef); err != nil </span><span class="cov0" title="0">{
                // Don't fail the entire operation if CLAUDE.md update fails
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ Warning: Failed to update CLAUDE.md: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// reportInstallResults prints a comprehensive report of installation results
func reportInstallResults(results []InstallResult) <span class="cov0" title="0">{
        fmt.Printf("\n📦 Installation Summary:\n")

        installed := 0
        updated := 0
        skipped := 0
        failed := 0

        for _, result := range results </span><span class="cov0" title="0">{
                switch result.Status </span>{
                case "installed":<span class="cov0" title="0">
                        fmt.Printf("✅ %s@%s → installed successfully\n", result.Package, result.Version)
                        installed++</span>
                case "updated":<span class="cov0" title="0">
                        fmt.Printf("✅ %s@%s → %s\n", result.Package, result.Version, result.Details)
                        updated++</span>
                case "skipped":<span class="cov0" title="0">
                        fmt.Printf("⏭️ %s@%s → %s\n", result.Package, result.Version, result.Details)
                        skipped++</span>
                case "failed":<span class="cov0" title="0">
                        fmt.Printf("❌ %s@%s → failed (%s)\n", result.Package, result.Version, result.Details)
                        failed++</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("\nSummary: %d installed, %d updated, %d skipped, %d failed\n", installed, updated, skipped, failed)

        if failed &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Some packages failed to install. Check network connectivity and registry access.\n")
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"
)

var (
        outputPath     string
        fileOverride   string // Single file override
        packageName    string // Non-interactive package name
        packageVersion string // Non-interactive package version
)

// packCmd represents the pack command
var packCmd = &amp;cobra.Command{
        Use:   "pack",
        Short: "Pack ruleset files into a distributable archive",
        Long: `Creates a tar.gz archive containing ruleset files and stages it for publishing.

The pack command supports both interactive and non-interactive modes:

Interactive mode:
   - rfh pack --file=my-rule.mdc
   - Prompts to add file to existing package or create new one
   - Handles version incrementing and directory management

Non-interactive mode:
   - rfh pack --file=my-rule.mdc --package="new-package"  # Creates new package at v1.0.0
   - rfh pack --file=my-rule.mdc --package="new-package" --version="1.2.0"  # Creates new package at v1.2.0

The pack command:
- Validates .mdc file format
- Updates rulestack.json with new/updated package info  
- Manages .rulestack package directories
- Creates staged archive ready for publishing
- Handles semantic version validation and incrementing

Examples:
  rfh pack --file=my-security-rule.mdc                                    # Interactive
  rfh pack --file=my-rule.mdc --package="new-rules"                      # Create new package
  rfh pack --file=my-rule.mdc --package="new-rules" --version="2.1.0"    # Create new package with version`,
        Args: cobra.NoArgs,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if fileOverride == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("--file flag is required")
                }</span>

                // Validate that the file is a .mdc file
                <span class="cov0" title="0">if !isValidMdcFile(fileOverride) </span><span class="cov0" title="0">{
                        return fmt.Errorf("file must be a valid .mdc file: %s", fileOverride)
                }</span>

                // Check if non-interactive mode
                <span class="cov0" title="0">if packageName != "" </span><span class="cov0" title="0">{
                        return runNonInteractivePack(fileOverride)
                }</span>

                <span class="cov0" title="0">return runInteractivePack(fileOverride)</span>
        },
}

func runInteractivePack(fileName string) error <span class="cov0" title="0">{
        // Pack is now much simpler - just create a new package
        // No need to read existing manifests, just prompt for package details
        return createNewPackage(fileName)
}</span>

func init() <span class="cov0" title="0">{
        packCmd.Flags().StringVarP(&amp;outputPath, "output", "o", "", "output archive path")
        packCmd.Flags().StringVarP(&amp;fileOverride, "file", "f", "", ".mdc file to pack (required)")

        // Non-interactive mode flags
        packCmd.Flags().StringVarP(&amp;packageName, "package", "p", "", "package name (enables non-interactive mode)")
        packCmd.Flags().StringVarP(&amp;packageVersion, "version", "", "", "package version (auto-increments for existing packages, defaults to 1.0.0 for new packages)")
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package cli

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "rulestack/internal/manifest"
        "rulestack/internal/version"
)

// promptUserChoice prompts user for a yes/no choice
func promptUserChoice(question string) (bool, error) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Printf("%s (y/n): ", question)
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to read input")
                }</span>

                <span class="cov0" title="0">response := strings.ToLower(strings.TrimSpace(scanner.Text()))
                switch response </span>{
                case "y", "yes":<span class="cov0" title="0">
                        return true, nil</span>
                case "n", "no":<span class="cov0" title="0">
                        return false, nil</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Please enter 'y' or 'n'")</span>
                }
        }
}

// promptUserInput prompts user for text input
func promptUserInput(question string) (string, error) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(os.Stdin)

        fmt.Printf("%s: ", question)
        if !scanner.Scan() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read input")
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(scanner.Text()), nil</span>
}

// promptPackageSelection shows existing packages and prompts user to select one
func promptPackageSelection(packageManifests manifest.PackageManifestFile) (int, error) <span class="cov0" title="0">{
        if len(packageManifests) == 0 </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("no existing packages found")
        }</span>

        <span class="cov0" title="0">fmt.Println("\nExisting packages:")
        for i, m := range packageManifests </span><span class="cov0" title="0">{
                fmt.Printf("  %d) %s (v%s) - %s\n", i+1, m.Name, m.Version, m.Description)
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Printf("Select package (1-%d): ", len(packageManifests))
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        return -1, fmt.Errorf("failed to read input")
                }</span>

                <span class="cov0" title="0">choice, err := strconv.Atoi(strings.TrimSpace(scanner.Text()))
                if err != nil || choice &lt; 1 || choice &gt; len(packageManifests) </span><span class="cov0" title="0">{
                        fmt.Printf("Please enter a number between 1 and %d\n", len(packageManifests))
                        continue</span>
                }

                <span class="cov0" title="0">return choice - 1, nil</span>
        }
}

// promptNewVersion prompts user for new version number with validation
func promptNewVersion(currentVersion string) (string, error) <span class="cov0" title="0">{
        nextPatch, err := version.IncrementPatchVersion(currentVersion)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Printf("Enter new version (current: %s, default: %s): ", currentVersion, nextPatch)
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read input")
                }</span>

                <span class="cov0" title="0">input := strings.TrimSpace(scanner.Text())
                if input == "" </span><span class="cov0" title="0">{
                        return nextPatch, nil
                }</span>

                <span class="cov0" title="0">if err := version.ValidateVersionIncrease(currentVersion, input); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">return input, nil</span>
        }
}

// isValidMdcFile checks if a file is a valid .mdc rules file
func isValidMdcFile(filePath string) bool <span class="cov0" title="0">{
        if !strings.HasSuffix(strings.ToLower(filePath), ".mdc") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// ensureDirectoryExists creates directory if it doesn't exist
func ensureDirectoryExists(dirPath string) error <span class="cov0" title="0">{
        return os.MkdirAll(dirPath, 0o755)
}</span>

// getPackageDirectory returns the package directory path in .rulestack
func getPackageDirectory(packageName, version string) string <span class="cov0" title="0">{
        return filepath.Join(".rulestack", fmt.Sprintf("%s.%s", packageName, version))
}</span>

// getStagingDirectory returns the staging directory path
func getStagingDirectory() string <span class="cov0" title="0">{
        return filepath.Join(".rulestack", "staged")
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package cli

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "rulestack/internal/manifest"
        "rulestack/internal/pkg"
        "rulestack/internal/version"
)

// ExistingPackageInfo holds information about an installed package
type ExistingPackageInfo struct {
        Name          string   // Package name (e.g., "security-rules")
        Version       string   // Current installed version (e.g., "1.0.0")
        Directory     string   // Full path to package directory (e.g., ".rulestack/security-rules.1.0.0")
        ExistingFiles []string // List of rule files in the package (e.g., ["rule1.mdc", "rule2.mdc"])
        ManifestPath  string   // Path to project's rulestack.json
}

// createNewPackage creates a new package with the given file
func createNewPackage(fileName string) error <span class="cov0" title="0">{
        // Prompt for package name
        packageName, err := promptUserInput("Enter new package name")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if packageName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("package name cannot be empty")
        }</span>

        <span class="cov0" title="0">return createPackageFromMetadata(fileName, packageName, "1.0.0")</span>
}

// createPackageFromMetadata creates a package with specified metadata (no manifest files saved)
func createPackageFromMetadata(fileName, packageName, version string) error <span class="cov0" title="0">{
        // Create package manifest in memory only
        packageManifest := &amp;manifest.PackageManifest{
                Name:        packageName,
                Version:     version,
                Description: fmt.Sprintf("Package containing %s", fileName),
                Files:       []string{fileName},
                Targets:     []string{"cursor"}, // Default target
                Tags:        []string{},
                License:     "MIT", // Default license
        }

        // Create package directory
        packageDir := getPackageDirectory(packageName, version)
        if err := ensureDirectoryExists(packageDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create package directory: %w", err)
        }</span>

        // Copy file to package directory
        <span class="cov0" title="0">destFile := filepath.Join(packageDir, fileName)
        if err := copyFile(fileName, destFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file to package directory: %w", err)
        }</span>

        // Create archive in staging directory with embedded manifest
        <span class="cov0" title="0">stagingDir := getStagingDirectory()
        if err := ensureDirectoryExists(stagingDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create staging directory: %w", err)
        }</span>

        // First, write the manifest to the package directory so it gets included in the archive
        // Use SaveSinglePackageManifest to save as object (not array) for archive embedding
        <span class="cov0" title="0">manifestPath := filepath.Join(packageDir, "rulestack.json")
        if err := manifest.SaveSinglePackageManifest(manifestPath, packageManifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write manifest to package directory: %w", err)
        }</span>

        <span class="cov0" title="0">archivePath := filepath.Join(stagingDir, fmt.Sprintf("%s-%s.tgz", packageName, version))
        info, err := pkg.PackFromDirectory(packageDir, archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create archive: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Created new package: %s v%s\n", packageName, version)
        fmt.Printf("📁 Package directory: %s\n", packageDir)
        fmt.Printf("📦 Archive: %s\n", info.Path)
        fmt.Printf("📏 Size: %d bytes\n", info.SizeBytes)
        fmt.Printf("🔒 SHA256: %s\n", info.SHA256)

        return nil</span>
}

// copyFile copies a file from source to destination
func copyFile(src, dst string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source file: %w", err)
        }</span>

        // Create directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(dst), 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(dst, data, 0o644)</span>
}

// runNonInteractivePack handles non-interactive pack mode with command-line flags
func runNonInteractivePack(fileName string) error <span class="cov0" title="0">{
        if packageName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--package is required in non-interactive mode")
        }</span>

        // Check if this package already exists as an installed dependency
        <span class="cov0" title="0">existingPkg, err := checkExistingPackage(packageName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check for existing package: %w", err)
        }</span>

        <span class="cov0" title="0">if existingPkg != nil </span><span class="cov0" title="0">{
                // Package exists - create updated version with all files
                fmt.Printf("📦 Found existing package %s@%s with %d files\n",
                        existingPkg.Name, existingPkg.Version, len(existingPkg.ExistingFiles))

                if packageVersion == "" </span><span class="cov0" title="0">{
                        // Auto-increment patch version if no version specified
                        nextVersion, err := version.IncrementPatchVersion(existingPkg.Version)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to auto-increment version: %w", err)
                        }</span>
                        <span class="cov0" title="0">packageVersion = nextVersion
                        fmt.Printf("🔄 Auto-incrementing version to %s\n", packageVersion)</span>
                }

                <span class="cov0" title="0">return createUpdatedPackage(fileName, packageName, packageVersion, existingPkg)</span>
        } else<span class="cov0" title="0"> {
                // Package doesn't exist - create new package (existing behavior)
                if packageVersion == "" </span><span class="cov0" title="0">{
                        packageVersion = "1.0.0" // Default version for new packages
                }</span>

                <span class="cov0" title="0">fmt.Printf("🆕 Creating new package %s@%s\n", packageName, packageVersion)
                return createNewPackageNonInteractive(fileName, packageName, packageVersion)</span>
        }
}

// createNewPackageNonInteractive creates a new package without prompts
func createNewPackageNonInteractive(fileName string, pkgName string, version string) error <span class="cov0" title="0">{
        return createPackageFromMetadata(fileName, pkgName, version)
}</span>

// checkExistingPackage looks for an installed package by name in the project
func checkExistingPackage(packageName string) (*ExistingPackageInfo, error) <span class="cov0" title="0">{
        // 1. Look for project manifest (rulestack.json in project root)
        manifestPath := "rulestack.json"

        // Check if project manifest exists
        if _, err := os.Stat(manifestPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil // No project manifest = no installed packages
        }</span>

        // 2. Load project manifest
        <span class="cov0" title="0">projectManifest, err := manifest.LoadProjectManifest(manifestPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load project manifest: %w", err)
        }</span>

        // 3. Check if package exists in dependencies
        <span class="cov0" title="0">if projectManifest.Dependencies == nil </span><span class="cov0" title="0">{
                return nil, nil // No dependencies
        }</span>

        <span class="cov0" title="0">currentVersion, exists := projectManifest.Dependencies[packageName]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil // Package not installed
        }</span>

        // 4. Verify package directory exists
        <span class="cov0" title="0">packageDir := getPackageDirectory(packageName, currentVersion)
        if _, err := os.Stat(packageDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("package %s@%s is in manifest but directory %s does not exist",
                        packageName, currentVersion, packageDir)
        }</span>

        // 5. Discover existing rule files in package directory
        <span class="cov0" title="0">existingFiles, err := findRuleFilesInDirectory(packageDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan existing files in %s: %w", packageDir, err)
        }</span>

        <span class="cov0" title="0">return &amp;ExistingPackageInfo{
                Name:          packageName,
                Version:       currentVersion,
                Directory:     packageDir,
                ExistingFiles: existingFiles,
                ManifestPath:  manifestPath,
        }, nil</span>
}

// findRuleFilesInDirectory scans a directory for .mdc rule files
func findRuleFilesInDirectory(dirPath string) ([]string, error) <span class="cov0" title="0">{
        var files []string

        entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span> // Skip subdirectories
                }

                <span class="cov0" title="0">name := entry.Name()
                // Include .mdc files but exclude rulestack.json manifest
                if strings.HasSuffix(strings.ToLower(name), ".mdc") &amp;&amp; name != "rulestack.json" </span><span class="cov0" title="0">{
                        files = append(files, name)
                }</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

// createUpdatedPackage creates a new version of an existing package with additional files
func createUpdatedPackage(fileName, packageName, newVersion string, existingPkg *ExistingPackageInfo) error <span class="cov0" title="0">{
        // Pre-flight validations

        // 1. Ensure new file exists and is readable
        if _, err := os.Stat(fileName); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("input file %s does not exist", fileName)
        }</span>

        // 2. Check for file name conflicts
        <span class="cov0" title="0">for _, existingFile := range existingPkg.ExistingFiles </span><span class="cov0" title="0">{
                if existingFile == fileName </span><span class="cov0" title="0">{
                        return fmt.Errorf("file %s already exists in package %s@%s, use a different filename or increment version to replace",
                                fileName, packageName, existingPkg.Version)
                }</span>
        }

        // 3. Validate file is .mdc format
        <span class="cov0" title="0">if !strings.HasSuffix(strings.ToLower(fileName), ".mdc") </span><span class="cov0" title="0">{
                return fmt.Errorf("file %s must be a .mdc rule file", fileName)
        }</span>

        // 4. Validate version increase using version package
        <span class="cov0" title="0">if err := version.ValidateVersionIncrease(existingPkg.Version, newVersion); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("version validation failed: %w", err)
        }</span>

        // 5. Create new package directory
        <span class="cov0" title="0">newPackageDir := getPackageDirectory(packageName, newVersion)
        if err := ensureDirectoryExists(newPackageDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create new package directory %s: %w", newPackageDir, err)
        }</span>

        // Set up cleanup on failure
        <span class="cov0" title="0">success := false
        defer func() </span><span class="cov0" title="0">{
                if !success </span><span class="cov0" title="0">{
                        // Clean up partial directory on failure
                        os.RemoveAll(newPackageDir)
                }</span>
        }()

        // 6. Copy ALL existing files from old package to new package
        <span class="cov0" title="0">for _, existingFile := range existingPkg.ExistingFiles </span><span class="cov0" title="0">{
                srcPath := filepath.Join(existingPkg.Directory, existingFile)
                destPath := filepath.Join(newPackageDir, existingFile)

                if err := copyFile(srcPath, destPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy existing file %s: %w", existingFile, err)
                }</span>
        }

        // 7. Copy new rule file to package directory
        <span class="cov0" title="0">newFilePath := filepath.Join(newPackageDir, fileName)
        if err := copyFile(fileName, newFilePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy new file %s: %w", fileName, err)
        }</span>

        // 8. Build complete file list for manifest
        <span class="cov0" title="0">allFiles := make([]string, 0, len(existingPkg.ExistingFiles)+1)
        allFiles = append(allFiles, existingPkg.ExistingFiles...)
        allFiles = append(allFiles, fileName)

        // 9. Create updated package manifest
        packageManifest := &amp;manifest.PackageManifest{
                Name:        packageName,
                Version:     newVersion,
                Description: fmt.Sprintf("Updated package containing %d rule files", len(allFiles)),
                Files:       allFiles,
                Targets:     []string{"cursor"}, // Default target
                Tags:        []string{},
                License:     "MIT", // Default license
        }

        // 10. Save manifest to new package directory
        manifestPath := filepath.Join(newPackageDir, "rulestack.json")
        if err := manifest.SaveSinglePackageManifest(manifestPath, packageManifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write manifest to new package directory: %w", err)
        }</span>

        // 11. Create archive in staging directory
        <span class="cov0" title="0">stagingDir := getStagingDirectory()
        if err := ensureDirectoryExists(stagingDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create staging directory: %w", err)
        }</span>

        <span class="cov0" title="0">archivePath := filepath.Join(stagingDir, fmt.Sprintf("%s-%s.tgz", packageName, newVersion))
        info, err := pkg.PackFromDirectory(newPackageDir, archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create archive: %w", err)
        }</span>

        // 12. Success output
        <span class="cov0" title="0">fmt.Printf("✅ Updated existing package: %s v%s -&gt; v%s\n", packageName, existingPkg.Version, newVersion)
        fmt.Printf("📁 Package directory: %s\n", newPackageDir)
        fmt.Printf("📦 Archive: %s\n", info.Path)
        fmt.Printf("📏 Size: %d bytes\n", info.SizeBytes)
        fmt.Printf("🔒 SHA256: %s\n", info.SHA256)
        fmt.Printf("📋 Files included: %s\n", strings.Join(allFiles, ", "))

        // Mark success at the end
        success = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cli

import (
        "fmt"
        "os"
        "path/filepath"

        "rulestack/internal/manifest"

        "github.com/spf13/cobra"
)

// projectrootCmd represents the projectroot command (temporary diagnostic tool)
var projectrootCmd = &amp;cobra.Command{
        Use:   "projectroot",
        Short: "Diagnostic tool to show project root discovery information",
        Long: `Shows detailed information about how RFH discovers and uses project roots.

This is a temporary diagnostic command to help troubleshoot path resolution issues.

The command displays:
1. Current working directory (where the command was invoked)
2. Location of the closest rulestack.json file found by walking up the directory tree
3. The registered project root from the rulestack.json file (if it exists)

This helps identify discrepancies between where commands are run and where RFH thinks
the project root should be.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runProjectRootDiagnostic()
        }</span>,
}

func runProjectRootDiagnostic() error <span class="cov0" title="0">{
        // 1. Get current working directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current working directory: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("📁 Current Working Directory: %s\n", cwd)

        // 2. Find closest rulestack.json using existing logic
        projectRoot, rulestackPath, err := findProjectRootWithPath()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ No rulestack.json found in directory tree\n")
                fmt.Printf("   Error: %v\n", err)
                return nil // Don't error out, this is diagnostic
        }</span>

        <span class="cov0" title="0">fmt.Printf("📄 Closest rulestack.json: %s\n", rulestackPath)

        // 3. Determine manifest type
        manifestType := "unknown"
        if manifest.IsProjectManifest(rulestackPath) </span><span class="cov0" title="0">{
                manifestType = "project manifest (dependency management)"
        }</span> else<span class="cov0" title="0"> if manifest.IsPackageManifest(rulestackPath) </span><span class="cov0" title="0">{
                manifestType = "package manifest (array of packages)"
        }</span>
        <span class="cov0" title="0">fmt.Printf("📋 Manifest Type: %s\n", manifestType)

        // 4. Show comparison
        fmt.Printf("\n--- Analysis ---\n")
        if projectRoot != cwd </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Working directory differs from discovered project root\n")
                fmt.Printf("   This may cause path resolution issues\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ Working directory matches discovered project root\n")
        }</span>

        <span class="cov0" title="0">fmt.Printf("ℹ️  Project root is determined by walking up directory tree to find rulestack.json\n")
        fmt.Printf("   The projectRoot field has been removed as it was not functionally used\n")

        return nil</span>
}

// findProjectRootWithPath is like findProjectRoot but also returns the path to the rulestack.json file
func findProjectRootWithPath() (string, string, error) <span class="cov0" title="0">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        // Walk up the directory tree looking for rulestack.json
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                manifestPath := filepath.Join(dir, "rulestack.json")
                if _, err := os.Stat(manifestPath); err == nil </span><span class="cov0" title="0">{
                        return dir, manifestPath, nil
                }</span>

                // Move to parent directory
                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        // Reached the root directory
                        break</span>
                }
                <span class="cov0" title="0">dir = parent</span>
        }

        <span class="cov0" title="0">return "", "", fmt.Errorf("no rulestack.json found in directory tree")</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(projectrootCmd)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"

        "rulestack/internal/client"
        "rulestack/internal/config"
        "rulestack/internal/manifest"
        "rulestack/internal/pkg"
)

// publishCmd represents the publish command
var publishCmd = &amp;cobra.Command{
        Use:   "publish",
        Short: "Publish staged rulesets to the registry",
        Long: `Publish all staged ruleset packages to the configured registry.

This command will:
1. Scan .rulestack/staged/ directory for archives
2. Extract embedded manifest data from each archive
3. Upload each archive to the registry
4. Clean up staged archives after successful upload

Archives must be created with 'rfh pack' command first.
Requires authentication token to be configured in the registry.`,
        Args: cobra.NoArgs,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runPublishStaged()
        }</span>,
}

func runPublishStaged() error <span class="cov0" title="0">{
        stagingDir := ".rulestack/staged"

        // Check if staging directory exists
        if _, err := os.Stat(stagingDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("no staged archives found. Use 'rfh pack' to create archives first")
        }</span>

        // Find all .tgz files in staging directory
        <span class="cov0" title="0">archives, err := filepath.Glob(filepath.Join(stagingDir, "*.tgz"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan staging directory: %w", err)
        }</span>

        <span class="cov0" title="0">if len(archives) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no archives found in staging directory. Use 'rfh pack' to create archives first")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d staged archive(s) to publish:\n", len(archives))
        for _, archivePath := range archives </span><span class="cov0" title="0">{
                fmt.Printf("  - %s\n", filepath.Base(archivePath))
        }</span>

        // Publish each archive
        <span class="cov0" title="0">successCount := 0
        for _, archivePath := range archives </span><span class="cov0" title="0">{
                if err := publishSingleArchive(archivePath); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to publish %s: %v\n", filepath.Base(archivePath), err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Successfully published %s\n", filepath.Base(archivePath))
                        // Remove archive after successful publish
                        os.Remove(archivePath)
                        successCount++
                }</span>
        }

        <span class="cov0" title="0">if successCount == len(archives) </span><span class="cov0" title="0">{
                fmt.Printf("\n🎉 All %d archive(s) published successfully!\n", successCount)
                return nil
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n⚠️  Published %d out of %d archive(s)\n", successCount, len(archives))
                return fmt.Errorf("failed to publish %d archive(s)", len(archives)-successCount)
        }</span>
}

// publishSingleArchive publishes a single archive file
func publishSingleArchive(archivePath string) error <span class="cov0" title="0">{
        // Extract manifest from archive
        manifestData, err := pkg.ExtractManifest(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract manifest from archive: %w", err)
        }</span>

        // Parse the manifest
        <span class="cov0" title="0">var packageManifest manifest.PackageManifest
        if err := json.Unmarshal(manifestData, &amp;packageManifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse manifest: %w", err)
        }</span>

        // Check if archive exists
        <span class="cov0" title="0">if _, err := os.Stat(archivePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("archive not found: %s", archivePath)
        }</span>

        // Get registry configuration
        <span class="cov0" title="0">cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Get current registry
        <span class="cov0" title="0">registryName, reg, err := getCurrentRegistry(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📦 Publishing %s v%s\n", packageManifest.Name, packageManifest.Version)
                fmt.Printf("🌐 Registry: %s (%s)\n", registryName, reg.URL)
                fmt.Printf("📄 Archive: %s\n", archivePath)
        }</span>

        // Create client using new factory
        <span class="cov0" title="0">c, err := client.GetClient(cfg, verbose)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Test registry connection
        <span class="cov0" title="0">ctx, cancel := client.WithTimeout(context.Background())
        defer cancel()
        
        if err := c.Health(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("registry health check failed: %w", err)
        }</span>

        // Create a temporary manifest file for this specific package (as single object, not array)
        <span class="cov0" title="0">archiveName := strings.TrimSuffix(filepath.Base(archivePath), ".tgz")
        tempManifestPath := fmt.Sprintf(".rulestack/staged/temp-manifest-%s.json", archiveName)
        if err := createSingleManifestFile(&amp;packageManifest, tempManifestPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp manifest: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempManifestPath) // Clean up temp file

        // Publish package
        fmt.Printf("🚀 Publishing %s v%s to %s...\n", packageManifest.Name, packageManifest.Version, reg.URL)
        result, err := c.PublishPackage(ctx, tempManifestPath, archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("publish failed: %w", err)
        }</span>

        // Show success message
        <span class="cov0" title="0">fmt.Printf("📌 Version: %s\n", result.Version)
        fmt.Printf("🔒 SHA256: %s\n", result.SHA256)

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("📋 Response: %+v\n", result)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// sanitizePackageName removes characters that are invalid in filenames
func sanitizePackageName(name string) string <span class="cov0" title="0">{
        // Replace invalid filename characters with safe alternatives
        safeName := strings.ReplaceAll(name, "@", "")
        safeName = strings.ReplaceAll(safeName, "/", "-")
        safeName = strings.ReplaceAll(safeName, "\\", "-")
        safeName = strings.ReplaceAll(safeName, ":", "-")
        safeName = strings.ReplaceAll(safeName, "*", "-")
        safeName = strings.ReplaceAll(safeName, "?", "-")
        safeName = strings.ReplaceAll(safeName, "\"", "-")
        safeName = strings.ReplaceAll(safeName, "&lt;", "-")
        safeName = strings.ReplaceAll(safeName, "&gt;", "-")
        safeName = strings.ReplaceAll(safeName, "|", "-")

        // Remove any leading/trailing spaces or dashes
        safeName = strings.Trim(safeName, " -")

        // Ensure we have a valid name
        if safeName == "" </span><span class="cov0" title="0">{
                safeName = "unnamed-package"
        }</span>

        <span class="cov0" title="0">return safeName</span>
}

// createSingleManifestFile creates a temporary manifest file with a single package entry
func createSingleManifestFile(packageManifest *manifest.PackageManifest, filePath string) error <span class="cov0" title="0">{
        // Create the manifest as a single object (not array) for API compatibility
        data, err := json.MarshalIndent(packageManifest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(filePath, data, 0o644)</span>
}

func init() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package cli

import (
        "fmt"
        "strings"

        "github.com/spf13/cobra"

        "rulestack/internal/config"
)

// registryCmd represents the registry command
var registryCmd = &amp;cobra.Command{
        Use:   "registry",
        Short: "Manage registries",
        Long: `Manage registry configurations for publishing and installing rulesets.

Registries are where rulesets are published and downloaded from. You can
configure multiple registries including public and private ones.`,
}

// registryAddCmd adds a new registry
var registryAddCmd = &amp;cobra.Command{
        Use:   "add &lt;name&gt; &lt;url&gt; [--type remote-http|git]",
        Short: "Add a new registry",
        Long: `Add a new registry configuration.

Registry Types:
  remote-http - Traditional HTTP-based registry (default)
  git        - Git repository-based registry

Examples:
  rfh registry add public https://registry.rulestack.dev
  rfh registry add github https://github.com/org/registry --type git`,
        Args: cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                name := args[0]
                url := args[1]
                registryType, _ := cmd.Flags().GetString("type")

                if registryType == "" </span><span class="cov0" title="0">{
                        registryType = string(config.RegistryTypeHTTP)
                }</span>

                <span class="cov0" title="0">return runRegistryAdd(name, url, config.RegistryType(registryType))</span>
        },
}

// registryListCmd lists configured registries
var registryListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List configured registries",
        Long:  `List all configured registries showing name, URL, and active status.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runRegistryList()
        }</span>,
}

// registryUseCmd sets the active registry
var registryUseCmd = &amp;cobra.Command{
        Use:   "use &lt;name&gt;",
        Short: "Set active registry",
        Long: `Set the active registry for publishing and installing packages.

The active registry is used when no --registry flag is specified.`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runRegistryUse(args[0])
        }</span>,
}

func runRegistryAdd(name, url string, registryType config.RegistryType) error <span class="cov0" title="0">{
        // Validate registry type
        if err := config.ValidateRegistryType(registryType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate URL based on type
        <span class="cov0" title="0">if registryType == config.RegistryTypeGit </span><span class="cov0" title="0">{
                if !strings.HasPrefix(url, "https://github.com/") &amp;&amp;
                        !strings.HasPrefix(url, "https://gitlab.com/") &amp;&amp;
                        !strings.HasPrefix(url, "git@") </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Warning: Git registry URL may not be valid\n")
                }</span>
        }

        <span class="cov0" title="0">cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Add registry with type
        <span class="cov0" title="0">cfg.Registries[name] = config.Registry{
                URL:  url,
                Type: registryType,
        }

        // Set as current if it's the first one
        if cfg.Current == "" </span><span class="cov0" title="0">{
                cfg.Current = name
        }</span>

        // Save config
        <span class="cov0" title="0">if err := config.SaveCLI(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Added registry '%s'\n", name)
        fmt.Printf("🌐 URL: %s\n", url)
        fmt.Printf("📋 Type: %s\n", registryType)

        if cfg.Current == name </span><span class="cov0" title="0">{
                fmt.Printf("⭐ Set as active registry\n")
        }</span>

        <span class="cov0" title="0">if registryType == config.RegistryTypeHTTP </span><span class="cov0" title="0">{
                fmt.Printf("💡 Use 'rfh auth login' to authenticate with this registry\n")
        }</span> else<span class="cov0" title="0"> if registryType == config.RegistryTypeGit </span><span class="cov0" title="0">{
                fmt.Printf("💡 Set git_token in config or use GITHUB_TOKEN environment variable for authentication\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runRegistryList() error <span class="cov0" title="0">{
        cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">if len(cfg.Registries) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No registries configured.\n")
                fmt.Printf("Add a registry with: rfh registry add &lt;name&gt; &lt;url&gt; [--type remote-http|git]\n")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("📋 Configured registries:\n\n")
        for name, reg := range cfg.Registries </span><span class="cov0" title="0">{
                marker := "  "
                if cfg.Current == name </span><span class="cov0" title="0">{
                        marker = "* "
                }</span>

                <span class="cov0" title="0">registryType := reg.GetEffectiveType()

                fmt.Printf("%s%s (%s)\n", marker, name, registryType)
                fmt.Printf("    URL: %s\n", reg.URL)

                // Show appropriate token status based on type
                if registryType == config.RegistryTypeHTTP &amp;&amp; reg.JWTToken != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    JWT Token: [configured]\n")
                }</span> else<span class="cov0" title="0"> if registryType == config.RegistryTypeGit &amp;&amp; reg.GitToken != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    Git Token: [configured]\n")
                }</span>

                <span class="cov0" title="0">fmt.Printf("\n")</span>
        }

        <span class="cov0" title="0">if cfg.Current != "" </span><span class="cov0" title="0">{
                fmt.Printf("* = active registry\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runRegistryUse(name string) error <span class="cov0" title="0">{
        cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Check if registry exists
        <span class="cov0" title="0">if _, exists := cfg.Registries[name]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("registry '%s' not found. Use 'rfh registry list' to see available registries", name)
        }</span>

        // Set as current
        <span class="cov0" title="0">cfg.Current = name

        // Save config
        if err := config.SaveCLI(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Set '%s' as active registry\n", name)
        fmt.Printf("🌐 URL: %s\n", cfg.Registries[name].URL)

        return nil</span>
}

// registryRemoveCmd removes a registry
var registryRemoveCmd = &amp;cobra.Command{
        Use:   "remove &lt;name&gt;",
        Short: "Remove a registry",
        Long: `Remove a registry configuration.

Examples:
  rfh registry remove old-registry
  rfh registry remove test`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runRegistryRemove(args[0])
        }</span>,
}

func runRegistryRemove(name string) error <span class="cov0" title="0">{
        cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Check if registry exists
        <span class="cov0" title="0">if _, exists := cfg.Registries[name]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("registry '%s' not found. Use 'rfh registry list' to see available registries", name)
        }</span>

        // Store URL for display
        <span class="cov0" title="0">url := cfg.Registries[name].URL

        // Remove the registry
        delete(cfg.Registries, name)

        // If this was the current registry, clear the current setting
        if cfg.Current == name </span><span class="cov0" title="0">{
                cfg.Current = ""
                fmt.Printf("⚠️  Removed active registry. Use 'rfh registry use' to set a new active registry.\n")
        }</span>

        // Save config
        <span class="cov0" title="0">if err := config.SaveCLI(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Removed registry '%s'\n", name)
        fmt.Printf("🌐 URL was: %s\n", url)

        return nil</span>
}

func init() <span class="cov0" title="0">{
        registryAddCmd.Flags().String("type", "remote-http", "Registry type (remote-http or git)")

        registryCmd.AddCommand(registryAddCmd)
        registryCmd.AddCommand(registryListCmd)
        registryCmd.AddCommand(registryUseCmd)
        registryCmd.AddCommand(registryRemoveCmd)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package cli

import (
        "fmt"
        "os"
        "strings"

        "github.com/spf13/cobra"

        "rulestack/internal/config"
)

var (
        verbose bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "rfh",
        Short: "RFH - Registry for Humans (AI ruleset manager)",
        Long: `RFH is a package manager for AI rulesets, allowing you to publish,
discover, and install AI rules for use with tools like Claude Code, Cursor, and Windsurf.

Registry for Humans - making AI rulesets accessible and shareable.`,
        PersistentPreRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Load .env file if it exists
                config.LoadEnvFile(".env")

                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("RFH version: 1.0.0\n")
                }</span>

                // Check for root user and display security warning
                <span class="cov0" title="0">if cfg, err := config.LoadCLI(); err == nil </span><span class="cov0" title="0">{
                        commandName := getFullCommandName(cmd)
                        checkAndWarnRootUser(cfg, commandName)
                }</span>
        },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)

        // Global flags
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "verbose output")

        // Add subcommands
        rootCmd.AddCommand(initCmd)
        rootCmd.AddCommand(packCmd)
        rootCmd.AddCommand(statusCmd)
        rootCmd.AddCommand(publishCmd)
        rootCmd.AddCommand(searchCmd)
        rootCmd.AddCommand(addCmd)
        rootCmd.AddCommand(installCmd)
        rootCmd.AddCommand(registryCmd)
        rootCmd.AddCommand(authCmd)
}</span>

// initConfig reads in config file and ENV variables if set.
func initConfig() {<span class="cov0" title="0">
        // No custom config file support - use defaults
}</span>

// Helper function to handle errors
func checkErr(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

// getFullCommandName returns the full command path (e.g., "rfh auth login")
func getFullCommandName(cmd *cobra.Command) string <span class="cov0" title="0">{
        var parts []string
        for current := cmd; current != nil &amp;&amp; current.Name() != ""; current = current.Parent() </span><span class="cov0" title="0">{
                parts = append([]string{current.Name()}, parts...)
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package cli

import (
        "context"
        "fmt"
        "strings"

        "github.com/spf13/cobra"

        "rulestack/internal/client"
        "rulestack/internal/config"
)

var (
        searchTag    string
        searchTarget string
        searchLimit  int
)

// searchCmd represents the search command
var searchCmd = &amp;cobra.Command{
        Use:   "search &lt;query&gt;",
        Short: "Search for rulesets in the registry",
        Long: `Search for rulesets in the configured registry.

You can filter results by tags and targets to find rulesets that match
your specific needs.

Examples:
  rfh search security
  rfh search "secure coding" --tag=javascript
  rfh search linting --target=cursor
  rfh search react --limit=10`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runSearch(args[0])
        }</span>,
}

func runSearch(query string) error <span class="cov0" title="0">{
        // Get registry configuration
        cfg, err := config.LoadCLI()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Use current registry (no overrides)
        <span class="cov0" title="0">registryName := cfg.Current

        if registryName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no registry configured. Use 'rfh registry add' to add a registry")
        }</span>

        <span class="cov0" title="0">reg, exists := cfg.Registries[registryName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("registry '%s' not found. Use 'rfh registry list' to see available registries", registryName)
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("🔍 Searching for: %s\n", query)
                fmt.Printf("🌐 Registry: %s (%s)\n", registryName, reg.URL)
                if searchTag != "" </span><span class="cov0" title="0">{
                        fmt.Printf("🏷️  Tag filter: %s\n", searchTag)
                }</span>
                <span class="cov0" title="0">if searchTarget != "" </span><span class="cov0" title="0">{
                        fmt.Printf("🎯 Target filter: %s\n", searchTarget)
                }</span>
        }

        // Create client using new factory
        <span class="cov0" title="0">c, err := client.GetClient(cfg, verbose)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Search packages using new interface
        <span class="cov0" title="0">ctx, cancel := client.WithTimeout(context.Background())
        defer cancel()
        
        opts := client.SearchOptions{
                Query:  query,
                Tag:    searchTag,
                Target: searchTarget,
                Limit:  searchLimit,
        }
        
        packages, err := c.SearchPackages(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("search failed: %w", err)
        }</span>

        <span class="cov0" title="0">if len(packages) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No rulesets found matching '%s'\n", query)
                if searchTag != "" || searchTarget != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Try removing filters or using different search terms.\n")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Display results
        <span class="cov0" title="0">fmt.Printf("📋 Found %d ruleset(s):\n\n", len(packages))

        for _, pkg := range packages </span><span class="cov0" title="0">{
                name := pkg.Name
                version := pkg.Latest
                description := pkg.Description

                fmt.Printf("📦 %s@%s\n", name, version)

                if description != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   %s\n", description)
                }</span>

                // Display versions
                <span class="cov0" title="0">if len(pkg.Versions) &gt; 1 </span><span class="cov0" title="0">{
                        fmt.Printf("   📋 Versions: %s\n", strings.Join(pkg.Versions, ", "))
                }</span>

                // Display tags
                <span class="cov0" title="0">if len(pkg.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   🏷️  Tags: %s\n", strings.Join(pkg.Tags, ", "))
                }</span>

                <span class="cov0" title="0">fmt.Printf("\n")</span>
        }

        <span class="cov0" title="0">fmt.Printf("💡 Install with: rfh add &lt;package-name&gt;@&lt;version&gt;\n")

        return nil</span>
}

func init() <span class="cov0" title="0">{
        searchCmd.Flags().StringVar(&amp;searchTag, "tag", "", "filter by tag")
        searchCmd.Flags().StringVar(&amp;searchTarget, "target", "", "filter by target (cursor, claude-code, etc.)")
        searchCmd.Flags().IntVar(&amp;searchLimit, "limit", 20, "limit number of results")
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package cli

import (
        "fmt"
        "path/filepath"

        "github.com/spf13/cobra"
)

// statusCmd represents the status command
var statusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Show packages staged for publishing",
        Long:  `Lists .tgz packages in the staging directory that are ready for publishing.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runStatus()
        }</span>,
}

func runStatus() error <span class="cov0" title="0">{
        stagingDir := ".rulestack/staged"
        pattern := filepath.Join(stagingDir, "*.tgz")

        files, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan staging directory: %w", err)
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No staged packages found")
                return nil
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                filename := filepath.Base(file)
                fmt.Println(filename)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package client

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

// AuthClient handles authentication API calls
type AuthClient struct {
        BaseURL string
        Client  *http.Client
}

// NewAuthClient creates a new authentication client
func NewAuthClient(baseURL string) *AuthClient <span class="cov0" title="0">{
        return &amp;AuthClient{
                BaseURL: baseURL,
                Client: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// RegisterRequest represents user registration data
type RegisterRequest struct {
        Username string `json:"username"`
        Email    string `json:"email"`
        Password string `json:"password"`
        Role     string `json:"role,omitempty"`
}

// LoginRequest represents login credentials
type LoginRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

// AuthResponse represents authentication response
type AuthResponse struct {
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
        User      struct {
                ID       int    `json:"id"`
                Username string `json:"username"`
                Email    string `json:"email"`
                Role     string `json:"role"`
        } `json:"user"`
        SessionID int `json:"session_id"`
}

// UserProfile represents user profile data
type UserProfile struct {
        ID        int        `json:"id"`
        Username  string     `json:"username"`
        Email     string     `json:"email"`
        Role      string     `json:"role"`
        CreatedAt time.Time  `json:"created_at"`
        UpdatedAt time.Time  `json:"updated_at"`
        LastLogin *time.Time `json:"last_login"`
}

// Register creates a new user account
func (c *AuthClient) Register(req RegisterRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        return c.authRequest("POST", "/v1/auth/register", req, nil)
}</span>

// Login authenticates a user and returns JWT token
func (c *AuthClient) Login(req LoginRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        return c.authRequest("POST", "/v1/auth/login", req, nil)
}</span>

// Logout invalidates the current session
func (c *AuthClient) Logout(token string) error <span class="cov0" title="0">{
        _, err := c.authRequest("POST", "/v1/auth/logout", nil, &amp;token)
        return err
}</span>

// GetProfile retrieves current user profile
func (c *AuthClient) GetProfile(token string) (*UserProfile, error) <span class="cov0" title="0">{
        body, err := c.makeRequest("GET", "/v1/auth/profile", nil, &amp;token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var profile UserProfile
        if err := json.Unmarshal(body, &amp;profile); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse profile response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;profile, nil</span>
}

// authRequest makes an authentication request and returns AuthResponse
func (c *AuthClient) authRequest(method, endpoint string, payload interface{}, token *string) (*AuthResponse, error) <span class="cov0" title="0">{
        body, err := c.makeRequest(method, endpoint, payload, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var authResp AuthResponse
        if err := json.Unmarshal(body, &amp;authResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse auth response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;authResp, nil</span>
}

// makeRequest makes an HTTP request to the API
func (c *AuthClient) makeRequest(method, endpoint string, payload interface{}, token *string) ([]byte, error) <span class="cov0" title="0">{
        var body io.Reader
        if payload != nil </span><span class="cov0" title="0">{
                jsonData, err := json.Marshal(payload)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request: %w", err)
                }</span>
                <span class="cov0" title="0">body = bytes.NewBuffer(jsonData)</span>
        }

        <span class="cov0" title="0">url := c.BaseURL + endpoint
        req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        if token != nil &amp;&amp; *token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+*token)
        }</span>

        <span class="cov0" title="0">resp, err := c.Client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                var errorResp struct {
                        Error string `json:"error"`
                }
                if err := json.Unmarshal(respBody, &amp;errorResp); err == nil &amp;&amp; errorResp.Error != "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("API error (%d): %s", resp.StatusCode, errorResp.Error)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("API error (%d): %s", resp.StatusCode, string(respBody))</span>
        }

        <span class="cov0" title="0">return respBody, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package client

import (
        "context"
)

// LegacyClient wraps the new client interface for backward compatibility
// This allows existing code that expects the old API to continue working
type LegacyClient struct {
        client RegistryClient
}

// NewLegacyClient creates a backward compatibility wrapper around a RegistryClient
func NewLegacyClient(client RegistryClient) *LegacyClient <span class="cov0" title="0">{
        return &amp;LegacyClient{client: client}
}</span>

// SearchPackages converts to old map-based format
func (l *LegacyClient) SearchPackages(query, tag, target string, limit int) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        ctx, cancel := WithTimeout(context.Background())
        defer cancel()

        opts := SearchOptions{
                Query:  query,
                Tag:    tag,
                Target: target,
                Limit:  limit,
        }

        packages, err := l.client.SearchPackages(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">results := make([]map[string]interface{}, len(packages))
        for i, pkg := range packages </span><span class="cov0" title="0">{
                results[i] = PackageToMap(&amp;pkg)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// GetPackage converts to old map-based format
func (l *LegacyClient) GetPackage(name string) (map[string]interface{}, error) <span class="cov0" title="0">{
        ctx, cancel := WithTimeout(context.Background())
        defer cancel()

        pkg, err := l.client.GetPackage(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return PackageToMap(pkg), nil</span>
}

// GetPackageVersion converts to old map-based format
func (l *LegacyClient) GetPackageVersion(name, version string) (map[string]interface{}, error) <span class="cov0" title="0">{
        ctx, cancel := WithTimeout(context.Background())
        defer cancel()

        pkgVersion, err := l.client.GetPackageVersion(ctx, name, version)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return PackageVersionToMap(pkgVersion), nil</span>
}

// PublishPackage converts to old map-based format
func (l *LegacyClient) PublishPackage(manifestPath, archivePath string) (map[string]interface{}, error) <span class="cov0" title="0">{
        ctx, cancel := WithTimeout(context.Background())
        defer cancel()

        result, err := l.client.PublishPackage(ctx, manifestPath, archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return PublishResultToMap(result), nil</span>
}

// DownloadBlob maintains the same signature
func (l *LegacyClient) DownloadBlob(sha256, destPath string) error <span class="cov0" title="0">{
        ctx, cancel := WithTimeout(context.Background())
        defer cancel()

        return l.client.DownloadBlob(ctx, sha256, destPath)
}</span>

// Health maintains the same signature
func (l *LegacyClient) Health() error <span class="cov0" title="0">{
        ctx, cancel := WithTimeout(context.Background())
        defer cancel()

        return l.client.Health(ctx)
}</span>

// SetVerbose is deprecated but maintained for compatibility
func (l *LegacyClient) SetVerbose(verbose bool) {<span class="cov0" title="0">
        // This is a no-op for the new interface since verbose is set during construction
        // We could potentially store this and create a new client, but that would be complex
        // For now, we'll just ignore this call since verbose mode is set when creating the client
}</pre>
		
		<pre class="file" id="file25" style="display: none">package client

import (
        "context"
        "time"
)

// DefaultTimeout is the default timeout for registry operations
const DefaultTimeout = 30 * time.Second

// WithTimeout creates a context with the default timeout
func WithTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov8" title="1">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="1">return context.WithTimeout(ctx, DefaultTimeout)</span>
}

// WithCustomTimeout creates a context with a custom timeout
func WithCustomTimeout(ctx context.Context, timeout time.Duration) (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov8" title="1">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="1">return context.WithTimeout(ctx, timeout)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package client

import "time"

// PackageToMap converts Package to map for backward compatibility
func PackageToMap(p *Package) map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "name":        p.Name,
                "description": p.Description,
                "latest":      p.Latest,
                "versions":    p.Versions,
                "tags":        p.Tags,
                "updated_at":  p.UpdatedAt,
        }
}</span>

// PackageVersionToMap converts PackageVersion to map
func PackageVersionToMap(pv *PackageVersion) map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "name":         pv.Name,
                "version":      pv.Version,
                "description":  pv.Description,
                "dependencies": pv.Dependencies,
                "sha256":       pv.SHA256,
                "size":         pv.Size,
                "published_at": pv.PublishedAt,
                "metadata":     pv.Metadata,
        }
}</span>

// MapToPackage converts map to Package struct
func MapToPackage(m map[string]interface{}) *Package <span class="cov8" title="1">{
        p := &amp;Package{}

        if name, ok := m["name"].(string); ok </span><span class="cov8" title="1">{
                p.Name = name
        }</span>
        <span class="cov8" title="1">if desc, ok := m["description"].(string); ok </span><span class="cov8" title="1">{
                p.Description = desc
        }</span>
        <span class="cov8" title="1">if latest, ok := m["latest"].(string); ok </span><span class="cov8" title="1">{
                p.Latest = latest
        }</span>
        <span class="cov8" title="1">if versions, ok := m["versions"].([]interface{}); ok </span><span class="cov8" title="1">{
                p.Versions = make([]string, len(versions))
                for i, v := range versions </span><span class="cov8" title="1">{
                        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                                p.Versions[i] = str
                        }</span>
                }
        }
        <span class="cov8" title="1">if tags, ok := m["tags"].([]interface{}); ok </span><span class="cov8" title="1">{
                p.Tags = make([]string, len(tags))
                for i, v := range tags </span><span class="cov8" title="1">{
                        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                                p.Tags[i] = str
                        }</span>
                }
        }
        <span class="cov8" title="1">if updatedAt, ok := m["updated_at"].(time.Time); ok </span><span class="cov8" title="1">{
                p.UpdatedAt = updatedAt
        }</span>

        <span class="cov8" title="1">return p</span>
}

// MapToPackageVersion converts map to PackageVersion struct
func MapToPackageVersion(m map[string]interface{}) *PackageVersion <span class="cov0" title="0">{
        pv := &amp;PackageVersion{}

        if name, ok := m["name"].(string); ok </span><span class="cov0" title="0">{
                pv.Name = name
        }</span>
        <span class="cov0" title="0">if version, ok := m["version"].(string); ok </span><span class="cov0" title="0">{
                pv.Version = version
        }</span>
        <span class="cov0" title="0">if desc, ok := m["description"].(string); ok </span><span class="cov0" title="0">{
                pv.Description = desc
        }</span>
        <span class="cov0" title="0">if deps, ok := m["dependencies"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                pv.Dependencies = make(map[string]string)
                for k, v := range deps </span><span class="cov0" title="0">{
                        if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                                pv.Dependencies[k] = str
                        }</span>
                }
        }
        <span class="cov0" title="0">if sha256, ok := m["sha256"].(string); ok </span><span class="cov0" title="0">{
                pv.SHA256 = sha256
        }</span>
        <span class="cov0" title="0">if size, ok := m["size"].(int64); ok </span><span class="cov0" title="0">{
                pv.Size = size
        }</span>
        <span class="cov0" title="0">if publishedAt, ok := m["published_at"].(time.Time); ok </span><span class="cov0" title="0">{
                pv.PublishedAt = publishedAt
        }</span>
        <span class="cov0" title="0">if metadata, ok := m["metadata"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                pv.Metadata = metadata
        }</span>

        <span class="cov0" title="0">return pv</span>
}

// PublishResultToMap converts PublishResult to map for backward compatibility
func PublishResultToMap(pr *PublishResult) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "name":    pr.Name,
                "version": pr.Version,
                "sha256":  pr.SHA256,
                "url":     pr.URL,
                "message": pr.Message,
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package client

import "fmt"

// Common registry error types
var (
        ErrPackageNotFound = fmt.Errorf("package not found")
        ErrVersionNotFound = fmt.Errorf("version not found")
        ErrUnauthorized    = fmt.Errorf("unauthorized")
        ErrRateLimited     = fmt.Errorf("rate limited")
        ErrNetworkError    = fmt.Errorf("network error")
        ErrInvalidManifest = fmt.Errorf("invalid manifest")
        ErrPublishFailed   = fmt.Errorf("publish failed")
)

// RegistryError provides detailed error information
type RegistryError struct {
        Type    error
        Message string
        Details map[string]interface{}
}

func (e *RegistryError) Error() string <span class="cov8" title="1">{
        if e.Message != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%v: %s", e.Type, e.Message)
        }</span>
        <span class="cov8" title="1">return e.Type.Error()</span>
}

func (e *RegistryError) Unwrap() error <span class="cov8" title="1">{
        return e.Type
}</span>

// NewRegistryError creates a new registry error
func NewRegistryError(errType error, message string) *RegistryError <span class="cov8" title="1">{
        return &amp;RegistryError{
                Type:    errType,
                Message: message,
                Details: make(map[string]interface{}),
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package client

import (
        "fmt"
        "rulestack/internal/config"
)

// NewRegistryClient creates the appropriate client based on registry type
func NewRegistryClient(registry config.Registry, verbose bool) (RegistryClient, error) <span class="cov8" title="1">{
        registryType := registry.GetEffectiveType()

        switch registryType </span>{
        case config.RegistryTypeHTTP:<span class="cov0" title="0">
                // Create new HTTP client that implements RegistryClient interface
                return NewHTTPClient(registry.URL, registry.JWTToken, verbose), nil</span>

        case config.RegistryTypeGit:<span class="cov8" title="1">
                // Git client will be implemented in later phases
                return NewGitRegistryClient(registry.URL, registry.GitToken, verbose)</span>

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported registry type: %s", registryType)</span>
        }
}

// GetClient creates a client for the current active registry
func GetClient(cfg config.CLIConfig, verbose bool) (RegistryClient, error) <span class="cov8" title="1">{
        if cfg.Current == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no active registry configured")
        }</span>

        <span class="cov8" title="1">registry, exists := cfg.Registries[cfg.Current]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("active registry '%s' not found in configuration", cfg.Current)
        }</span>

        <span class="cov0" title="0">return NewRegistryClient(registry, verbose)</span>
}

// GetClientForRegistry creates a client for a specific named registry
func GetClientForRegistry(cfg config.CLIConfig, registryName string, verbose bool) (RegistryClient, error) <span class="cov8" title="1">{
        registry, exists := cfg.Registries[registryName]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("registry '%s' not found", registryName)
        }</span>

        <span class="cov0" title="0">return NewRegistryClient(registry, verbose)</span>
}

// Placeholder functions for clients that will be implemented in later phases


// NewGitRegistryClient creates a new Git-based registry client
// This will be implemented in Phase 5: Git Client Implementation
func NewGitRegistryClient(repoURL, gitToken string, verbose bool) (RegistryClient, error) <span class="cov8" title="1">{
        // This is a placeholder - will be implemented in Phase 5
        return nil, fmt.Errorf("Git registry client not yet implemented - will be added in Phase 5")
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package client

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "rulestack/internal/config"
)

// HTTPClient represents an HTTP client for the RuleStack registry
type HTTPClient struct {
        baseURL    string
        token      string
        httpClient *http.Client
        verbose    bool
}

// Ensure HTTPClient implements RegistryClient
var _ RegistryClient = (*HTTPClient)(nil)

// NewHTTPClient creates a new HTTP registry client
func NewHTTPClient(baseURL, token string, verbose bool) *HTTPClient <span class="cov0" title="0">{
        baseURL = strings.TrimRight(baseURL, "/")

        return &amp;HTTPClient{
                baseURL: baseURL,
                token:   token,
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                verbose: verbose,
        }
}</span>

// Type returns the registry type
func (c *HTTPClient) Type() config.RegistryType <span class="cov0" title="0">{
        return config.RegistryTypeHTTP
}</span>

// SearchPackages searches for packages in the registry
func (c *HTTPClient) SearchPackages(ctx context.Context, opts SearchOptions) ([]Package, error) <span class="cov0" title="0">{
        path := "/v1/packages"

        // Build query parameters
        params := url.Values{}
        if opts.Query != "" </span><span class="cov0" title="0">{
                params.Add("q", opts.Query)
        }</span>
        <span class="cov0" title="0">if opts.Tag != "" </span><span class="cov0" title="0">{
                params.Add("tag", opts.Tag)
        }</span>
        <span class="cov0" title="0">if opts.Target != "" </span><span class="cov0" title="0">{
                params.Add("target", opts.Target)
        }</span>
        <span class="cov0" title="0">if opts.Limit &gt; 0 </span><span class="cov0" title="0">{
                params.Add("limit", strconv.Itoa(opts.Limit))
        }</span>

        <span class="cov0" title="0">if len(params) &gt; 0 </span><span class="cov0" title="0">{
                path += "?" + params.Encode()
        }</span>

        <span class="cov0" title="0">resp, err := c.makeRequestWithContext(ctx, "GET", path, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, NewRegistryError(ErrNetworkError,
                        fmt.Sprintf("search failed (status %d): %s", resp.StatusCode, string(body)))
        }</span>

        // Parse response as maps first (for backward compatibility)
        <span class="cov0" title="0">var results []map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;results); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        // Convert to Package structs
        <span class="cov0" title="0">packages := make([]Package, len(results))
        for i, r := range results </span><span class="cov0" title="0">{
                packages[i] = *MapToPackage(r)
        }</span>

        <span class="cov0" title="0">return packages, nil</span>
}

// GetPackage gets information about a specific package
func (c *HTTPClient) GetPackage(ctx context.Context, name string) (*Package, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/packages/%s", name)

        resp, err := c.makeRequestWithContext(ctx, "GET", path, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, NewRegistryError(ErrPackageNotFound, name)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, NewRegistryError(ErrNetworkError,
                        fmt.Sprintf("request failed (status %d): %s", resp.StatusCode, string(body)))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return MapToPackage(result), nil</span>
}

// GetPackageVersion gets information about a specific package version
func (c *HTTPClient) GetPackageVersion(ctx context.Context, name, version string) (*PackageVersion, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/packages/%s/versions/%s", name, version)

        resp, err := c.makeRequestWithContext(ctx, "GET", path, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return nil, NewRegistryError(ErrVersionNotFound,
                        fmt.Sprintf("%s@%s", name, version))
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, NewRegistryError(ErrNetworkError,
                        fmt.Sprintf("request failed (status %d): %s", resp.StatusCode, string(body)))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return MapToPackageVersion(result), nil</span>
}

// PublishPackage publishes a package to the registry
func (c *HTTPClient) PublishPackage(ctx context.Context, manifestPath, archivePath string) (*PublishResult, error) <span class="cov0" title="0">{
        // Create multipart form
        var buf bytes.Buffer
        writer := multipart.NewWriter(&amp;buf)

        // Add manifest file
        if err := c.addFileToForm(writer, "manifest", manifestPath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add manifest: %w", err)
        }</span>

        // Add archive file
        <span class="cov0" title="0">if err := c.addFileToForm(writer, "archive", archivePath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add archive: %w", err)
        }</span>

        <span class="cov0" title="0">writer.Close()

        // Make request
        resp, err := c.makeRequestWithContext(ctx, "POST", "/v1/packages", &amp;buf, writer.FormDataContentType())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, _ := io.ReadAll(resp.Body)

        if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                return nil, NewRegistryError(ErrUnauthorized, "authentication required")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, NewRegistryError(ErrPublishFailed,
                        fmt.Sprintf("status %d: %s", resp.StatusCode, string(body)))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;PublishResult{
                Name:    getStringFromMap(result, "name"),
                Version: getStringFromMap(result, "version"),
                SHA256:  getStringFromMap(result, "sha256"),
                URL:     c.baseURL + "/v1/packages",
                Message: "Package published successfully",
        }, nil</span>
}

// DownloadBlob downloads a blob by SHA256 hash
func (c *HTTPClient) DownloadBlob(ctx context.Context, sha256, destPath string) error <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/blobs/%s", sha256)

        resp, err := c.makeRequestWithContext(ctx, "GET", path, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return NewRegistryError(ErrNetworkError,
                        fmt.Sprintf("download failed (status %d): %s", resp.StatusCode, string(body)))
        }</span>

        // Create destination file
        <span class="cov0" title="0">outFile, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        // Copy data
        _, err = io.Copy(outFile, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov0" title="0">if c.verbose </span><span class="cov0" title="0">{
                fmt.Printf("📥 Downloaded %s\n", destPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Health checks if the registry is healthy
func (c *HTTPClient) Health(ctx context.Context) error <span class="cov0" title="0">{
        resp, err := c.makeRequestWithContext(ctx, "GET", "/v1/health", nil, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return NewRegistryError(ErrNetworkError,
                        fmt.Sprintf("registry health check failed (status %d)", resp.StatusCode))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// makeRequestWithContext makes an HTTP request with authentication and context
func (c *HTTPClient) makeRequestWithContext(ctx context.Context, method, path string, body io.Reader, contentType string) (*http.Response, error) <span class="cov0" title="0">{
        url := c.baseURL + path

        if c.verbose </span><span class="cov0" title="0">{
                fmt.Printf("🌐 %s %s\n", method, url)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add authentication header
        <span class="cov0" title="0">if c.token != "" </span><span class="cov0" title="0">{
                authHeader := "Bearer " + c.token
                req.Header.Set("Authorization", authHeader)
                if c.verbose </span><span class="cov0" title="0">{
                        tokenPreview := c.token
                        if len(tokenPreview) &gt; 20 </span><span class="cov0" title="0">{
                                tokenPreview = tokenPreview[:20] + "..."
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("🔍 Setting Authorization header: Bearer %s\n", tokenPreview)</span>
                }
        } else<span class="cov0" title="0"> if c.verbose </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  No token available - sending request without Authorization header\n")
        }</span>

        // Set content type if provided
        <span class="cov0" title="0">if contentType != "" </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", contentType)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("request canceled: %w", ctx.Err())
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("request failed: %w", err)</span>
        }

        <span class="cov0" title="0">if c.verbose </span><span class="cov0" title="0">{
                fmt.Printf("🔍 HTTP Response: %d %s\n", resp.StatusCode, resp.Status)
                if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                        // Log response headers for debugging auth issues
                        authHeader := resp.Request.Header.Get("Authorization")
                        if authHeader != "" </span><span class="cov0" title="0">{
                                tokenPart := authHeader[7:] // Remove "Bearer "
                                if len(tokenPart) &gt; 20 </span><span class="cov0" title="0">{
                                        tokenPart = tokenPart[:20] + "..."
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("🔍 Request had Authorization: Bearer %s\n", tokenPart)</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("⚠️  Request had no Authorization header\n")
                        }</span>
                }
        }

        <span class="cov0" title="0">return resp, nil</span>
}

// addFileToForm adds a file to a multipart form
func (c *HTTPClient) addFileToForm(writer *multipart.Writer, fieldName, filePath string) error <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        part, err := writer.CreateFormFile(fieldName, filepath.Base(filePath))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = io.Copy(part, file)
        return err</span>
}

// getStringFromMap safely gets a string value from a map
func getStringFromMap(m map[string]interface{}, key string) string <span class="cov0" title="0">{
        if val, ok := m[key]; ok </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/pelletier/go-toml/v2"
)

type RegistryType string

const (
        RegistryTypeHTTP RegistryType = "remote-http"
        RegistryTypeGit  RegistryType = "git"
)

type Registry struct {
        URL      string       `toml:"url"`
        Type     RegistryType `toml:"type"`                // New field
        Username string       `toml:"username,omitempty"`  // Username for this registry
        JWTToken string       `toml:"jwt_token,omitempty"` // JWT token for this registry
        GitToken string       `toml:"git_token,omitempty"` // New field for git auth
}

type CLIConfig struct {
        Current    string              `toml:"current"`
        Registries map[string]Registry `toml:"registries"`
}

// ConfigDir returns the CLI config directory path
// It first checks the RFH_CONFIG environment variable for a custom config location.
// If not set, it falls back to the default ~/.rfh directory.
func ConfigDir() (string, error) <span class="cov8" title="1">{
        // Check for RFH_CONFIG environment variable first
        if rfhConfig := os.Getenv("RFH_CONFIG"); rfhConfig != "" </span><span class="cov8" title="1">{
                return rfhConfig, nil
        }</span>

        // Fall back to default ~/.rfh location
        <span class="cov8" title="1">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return filepath.Join(home, ".rfh"), nil</span>
}

// ConfigPath returns the full path to config.toml
func ConfigPath() (string, error) <span class="cov8" title="1">{
        dir, err := ConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return filepath.Join(dir, "config.toml"), nil</span>
}

// LoadCLI loads CLI configuration from ~/.rfh/config.toml
func LoadCLI() (CLIConfig, error) <span class="cov8" title="1">{
        configPath, err := ConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return CLIConfig{}, err
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                // Return empty config if file doesn't exist
                return CLIConfig{
                        Registries: make(map[string]Registry),
                }, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return CLIConfig{}, err
        }</span>

        <span class="cov8" title="1">var config CLIConfig
        if err := toml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return CLIConfig{}, err
        }</span>

        <span class="cov8" title="1">if config.Registries == nil </span><span class="cov0" title="0">{
                config.Registries = make(map[string]Registry)
        }</span>

        // Migrate existing registries to have explicit type
        <span class="cov8" title="1">for name, reg := range config.Registries </span><span class="cov8" title="1">{
                if reg.Type == "" </span><span class="cov8" title="1">{
                        reg.Type = RegistryTypeHTTP
                        config.Registries[name] = reg
                }</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// SaveCLI saves CLI configuration to ~/.rfh/config.toml
func SaveCLI(config CLIConfig) error <span class="cov8" title="1">{
        configPath, err := ConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure config directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(configPath), 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">data, err := toml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(configPath, data, 0o600)</span>
}

// ValidateRegistryType checks if a registry type is valid
func ValidateRegistryType(t RegistryType) error <span class="cov0" title="0">{
        switch t </span>{
        case RegistryTypeHTTP, RegistryTypeGit:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported registry type: %s", t)</span>
        }
}

// GetEffectiveType returns the effective type for a registry
func (r Registry) GetEffectiveType() RegistryType <span class="cov0" title="0">{
        if r.Type == "" </span><span class="cov0" title="0">{
                return RegistryTypeHTTP
        }</span>
        <span class="cov0" title="0">return r.Type</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package config

import (
        "log"
        "os"
)

type Config struct {
        DBURL       string
        StoragePath string
        APIPort     string
        TokenSalt   string
        JWTSecret   string
}

func Load() Config <span class="cov8" title="1">{
        cfg := Config{
                DBURL:       os.Getenv("DATABASE_URL"),
                StoragePath: getEnv("STORAGE_PATH", "./storage"),
                APIPort:     getEnv("PORT", "8080"),
                TokenSalt:   os.Getenv("TOKEN_SALT"),
                JWTSecret:   os.Getenv("JWT_SECRET"),
        }

        // Validate required fields
        if cfg.DBURL == "" </span><span class="cov0" title="0">{
                log.Fatal("DATABASE_URL environment variable is required")
        }</span>
        <span class="cov8" title="1">if cfg.TokenSalt == "" </span><span class="cov0" title="0">{
                log.Fatal("TOKEN_SALT environment variable is required")
        }</span>
        <span class="cov8" title="1">if cfg.JWTSecret == "" </span><span class="cov0" title="0">{
                log.Fatal("JWT_SECRET environment variable is required")
        }</span>

        <span class="cov8" title="1">return cfg</span>
}

func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package config

import (
        "bufio"
        "os"
        "strings"
)

// LoadEnvFile loads environment variables from a .env file
func LoadEnvFile(filename string) error <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err // File might not exist, which is okay
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Split on first = sign
                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Only set if not already set in environment
                if os.Getenv(key) == "" </span><span class="cov0" title="0">{
                        os.Setenv(key, value)
                }</span>
        }

        <span class="cov0" title="0">return scanner.Err()</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package db

import (
        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq" // postgres driver
)

// DB holds the database connection
type DB struct {
        *sqlx.DB
}

// Connect establishes a connection to the database
func Connect(databaseURL string) (*DB, error) <span class="cov0" title="0">{
        sqlxDB, err := sqlx.Connect("postgres", databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Test the connection
        <span class="cov0" title="0">if err := sqlxDB.Ping(); err != nil </span><span class="cov0" title="0">{
                sqlxDB.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;DB{sqlxDB}, nil</span>
}

// Close closes the database connection
func (db *DB) Close() error <span class="cov0" title="0">{
        return db.DB.Close()
}</span>

// Health checks if the database connection is healthy
func (db *DB) Health() error <span class="cov0" title="0">{
        return db.Ping()
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package db

import (
        "time"

        "github.com/lib/pq"
)

// Package represents a package in the registry
type Package struct {
        ID        int       `db:"id" json:"id"`
        Name      string    `db:"name" json:"name"`
        CreatedAt time.Time `db:"created_at" json:"created_at"`
}

// PackageVersion represents a specific version of a package
type PackageVersion struct {
        ID          int            `db:"id" json:"id"`
        PackageID   int            `db:"package_id" json:"package_id"`
        Version     string         `db:"version" json:"version"`
        Description *string        `db:"description" json:"description"`
        Targets     pq.StringArray `db:"targets" json:"targets"`
        Tags        pq.StringArray `db:"tags" json:"tags"`
        SHA256      *string        `db:"sha256" json:"sha256"`
        SizeBytes   *int           `db:"size_bytes" json:"size_bytes"`
        BlobPath    *string        `db:"blob_path" json:"blob_path"`
        CreatedAt   time.Time      `db:"created_at" json:"created_at"`
}

// PackageInfo combines package and version info for API responses
type PackageInfo struct {
        Package
        Versions []PackageVersion `json:"versions"`
}

// SearchResult represents a search result
type SearchResult struct {
        ID          int            `db:"id" json:"id"`
        Name        string         `db:"name" json:"name"`
        Version     string         `db:"version" json:"version"`
        Description *string        `db:"description" json:"description"`
        Targets     pq.StringArray `db:"targets" json:"targets"`
        Tags        pq.StringArray `db:"tags" json:"tags"`
        CreatedAt   time.Time      `db:"created_at" json:"created_at"`
}

// FullPackageName returns the package name (no scope support)
func (p *Package) FullPackageName() string <span class="cov8" title="1">{
        return p.Name
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package db

import (
        "database/sql"
        "fmt"
)

// GetOrCreatePackage gets existing package or creates new one
func (db *DB) GetOrCreatePackage(name string) (*Package, error) <span class="cov0" title="0">{
        // First try to get existing
        pkg, err := db.GetPackage(name)
        if err == nil </span><span class="cov0" title="0">{
                return pkg, nil
        }</span>
        <span class="cov0" title="0">if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create new package
        <span class="cov0" title="0">query := `
        INSERT INTO packages (name) 
        VALUES ($1) 
        RETURNING id, name, created_at`

        var newPkg Package
        err = db.Get(&amp;newPkg, query, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;newPkg, nil</span>
}

// GetPackage retrieves a package by name
func (db *DB) GetPackage(name string) (*Package, error) <span class="cov0" title="0">{
        query := `SELECT id, name, created_at FROM packages WHERE name = $1`

        var pkg Package
        err := db.Get(&amp;pkg, query, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;pkg, nil</span>
}

// CreatePackageVersion creates a new package version
func (db *DB) CreatePackageVersion(version PackageVersion) (*PackageVersion, error) <span class="cov0" title="0">{
        query := `
        INSERT INTO package_versions 
        (package_id, version, description, targets, tags, sha256, size_bytes, blob_path)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id, package_id, version, description, targets, tags, sha256, size_bytes, blob_path, created_at`

        var newVersion PackageVersion
        err := db.Get(&amp;newVersion, query,
                version.PackageID,
                version.Version,
                version.Description,
                version.Targets,
                version.Tags,
                version.SHA256,
                version.SizeBytes,
                version.BlobPath,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;newVersion, nil</span>
}

// GetPackageVersion retrieves a specific version of a package
func (db *DB) GetPackageVersion(name string, version string) (*PackageVersion, error) <span class="cov0" title="0">{
        query := `
                SELECT pv.id, pv.package_id, pv.version, pv.description, pv.targets, pv.tags, 
                           pv.sha256, pv.size_bytes, pv.blob_path, pv.created_at
                FROM package_versions pv
                JOIN packages p ON p.id = pv.package_id
                WHERE p.name = $1 AND pv.version = $2`

        fmt.Printf("[DEBUG] GetPackageVersion SQL query: %s\n", query)
        fmt.Printf("[DEBUG] GetPackageVersion parameters: [%s, %s]\n", name, version)

        var pkgVersion PackageVersion
        err := db.Get(&amp;pkgVersion, query, name, version)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR] GetPackageVersion SQL error: %v\n", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">fmt.Printf("[DEBUG] GetPackageVersion found: %+v\n", pkgVersion)
        return &amp;pkgVersion, nil</span>
}

// SearchPackages searches for packages
func (db *DB) SearchPackages(query string, tag string, target string, limit int) ([]SearchResult, error) <span class="cov0" title="0">{
        sqlQuery := `
        SELECT DISTINCT p.id, p.name, pv.version, pv.description, pv.targets, pv.tags, p.created_at
        FROM packages p
        JOIN package_versions pv ON p.id = pv.package_id
        WHERE 1=1`

        args := []interface{}{}
        argCount := 0

        // Add search conditions
        if query != "" </span><span class="cov0" title="0">{
                argCount++
                sqlQuery += fmt.Sprintf(" AND (p.name ILIKE $%d OR pv.description ILIKE $%d)", argCount, argCount)
                args = append(args, "%"+query+"%")
        }</span>

        <span class="cov0" title="0">if tag != "" </span><span class="cov0" title="0">{
                argCount++
                sqlQuery += fmt.Sprintf(" AND $%d = ANY(pv.tags)", argCount)
                args = append(args, tag)
        }</span>

        <span class="cov0" title="0">if target != "" </span><span class="cov0" title="0">{
                argCount++
                sqlQuery += fmt.Sprintf(" AND $%d = ANY(pv.targets)", argCount)
                args = append(args, target)
        }</span>

        <span class="cov0" title="0">sqlQuery += " ORDER BY p.created_at DESC"

        if limit &gt; 0 </span><span class="cov0" title="0">{
                argCount++
                sqlQuery += fmt.Sprintf(" LIMIT $%d", argCount)
                args = append(args, limit)
        }</span>

        <span class="cov0" title="0">var results []SearchResult
        err := db.Select(&amp;results, sqlQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package db

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "golang.org/x/crypto/bcrypt"
)

// UserRole represents user access levels
type UserRole string

const (
        RoleUser      UserRole = "user"
        RolePublisher UserRole = "publisher"
        RoleAdmin     UserRole = "admin"
        RoleRoot      UserRole = "root"
)

// Value implements the driver.Valuer interface for database storage
func (r UserRole) Value() (driver.Value, error) <span class="cov0" title="0">{
        return string(r), nil
}</span>

// Scan implements the sql.Scanner interface for database retrieval
func (r *UserRole) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *r = RoleUser
                return nil
        }</span>
        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                *r = UserRole(v)
                return nil</span>
        case []byte:<span class="cov0" title="0">
                *r = UserRole(string(v))
                return nil</span>
        case UserRole:<span class="cov0" title="0">
                *r = v
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("cannot scan UserRole from type " + fmt.Sprintf("%T", value))</span>
        }
}

// MarshalJSON implements the json.Marshaler interface for JSON serialization
func (r UserRole) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(string(r))
}</span>

// UnmarshalJSON implements the json.Unmarshaler interface for JSON deserialization
func (r *UserRole) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var str string
        if err := json.Unmarshal(data, &amp;str); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*r = UserRole(str)
        return nil</span>
}

// User represents a user account
type User struct {
        ID           int        `json:"id" db:"id"`
        Username     string     `json:"username" db:"username"`
        Email        string     `json:"email" db:"email"`
        PasswordHash string     `json:"-" db:"password_hash"`
        Role         UserRole   `json:"role" db:"role"`
        CreatedAt    time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time  `json:"updated_at" db:"updated_at"`
        LastLogin    *time.Time `json:"last_login" db:"last_login"`
        IsActive     bool       `json:"is_active" db:"is_active"`
}

// UserSession represents a user authentication session
type UserSession struct {
        ID        int       `json:"id" db:"id"`
        UserID    int       `json:"user_id" db:"user_id"`
        TokenHash string    `json:"-" db:"token_hash"`
        ExpiresAt time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        LastUsed  time.Time `json:"last_used" db:"last_used"`
        UserAgent *string   `json:"user_agent" db:"user_agent"`
        IPAddress *string   `json:"ip_address" db:"ip_address"`
}

// CreateUserRequest represents user registration data
type CreateUserRequest struct {
        Username string   `json:"username"`
        Email    string   `json:"email"`
        Password string   `json:"password"`
        Role     UserRole `json:"role"`
}

// LoginRequest represents login credentials
type LoginRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

// ChangePasswordRequest represents password change data
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password"`
        NewPassword     string `json:"new_password"`
}

// CreateUser creates a new user account
func (db *DB) CreateUser(req CreateUserRequest) (*User, error) <span class="cov0" title="0">{
        // Hash the password
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO users (username, email, password_hash, role)
                VALUES ($1, $2, $3, $4)
                RETURNING id, username, email, password_hash, role, created_at, updated_at, last_login, is_active`

        var user User
        err = db.Get(&amp;user, query, req.Username, req.Email, string(hashedPassword), req.Role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserByUsername retrieves a user by username
func (db *DB) GetUserByUsername(username string) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, role, created_at, updated_at, last_login, is_active
                FROM users 
                WHERE username = $1 AND is_active = true`

        var user User
        err := db.Get(&amp;user, query, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserByID retrieves a user by ID
func (db *DB) GetUserByID(id int) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, role, created_at, updated_at, last_login, is_active
                FROM users 
                WHERE id = $1 AND is_active = true`

        var user User
        err := db.Get(&amp;user, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// ValidatePassword checks if the provided password matches the user's password
func (db *DB) ValidatePassword(user *User, password string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
        return err == nil
}</span>

// CreateUserSession creates a new user session
func (db *DB) CreateUserSession(userID int, tokenHash string, expiresAt time.Time, userAgent, ipAddress *string) (*UserSession, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO user_sessions (user_id, token_hash, expires_at, user_agent, ip_address)
                VALUES ($1, $2, $3, $4, $5)
                RETURNING id, user_id, token_hash, expires_at, created_at, last_used, user_agent, ip_address`

        var session UserSession
        err := db.Get(&amp;session, query, userID, tokenHash, expiresAt, userAgent, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}

// ValidateUserSession validates a session token and returns user info
func (db *DB) ValidateUserSession(tokenHash string) (*User, *UserSession, error) <span class="cov0" title="0">{
        query := `
                SELECT u.id, u.username, u.email, u.password_hash, u.role, u.created_at, u.updated_at, u.last_login, u.is_active,
                       s.id, s.user_id, s.token_hash, s.expires_at, s.created_at, s.last_used, s.user_agent, s.ip_address
                FROM users u
                JOIN user_sessions s ON u.id = s.user_id
                WHERE s.token_hash = $1 AND s.expires_at &gt; now() AND u.is_active = true`

        rows, err := db.Query(query, tokenHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        if !rows.Next() </span><span class="cov0" title="0">{
                return nil, nil, errors.New("invalid or expired session")
        }</span>

        <span class="cov0" title="0">var user User
        var session UserSession

        err = rows.Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Role,
                &amp;user.CreatedAt, &amp;user.UpdatedAt, &amp;user.LastLogin, &amp;user.IsActive,
                &amp;session.ID, &amp;session.UserID, &amp;session.TokenHash, &amp;session.ExpiresAt,
                &amp;session.CreatedAt, &amp;session.LastUsed, &amp;session.UserAgent, &amp;session.IPAddress,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, &amp;session, nil</span>
}

// UpdateLastLogin updates the user's last login timestamp
func (db *DB) UpdateLastLogin(userID int) error <span class="cov0" title="0">{
        query := `UPDATE users SET last_login = now() WHERE id = $1`
        _, err := db.Exec(query, userID)
        return err
}</span>

// UpdateSessionLastUsed updates the session's last used timestamp
func (db *DB) UpdateSessionLastUsed(sessionID int) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET last_used = now() WHERE id = $1`
        _, err := db.Exec(query, sessionID)
        return err
}</span>

// ChangeUserPassword changes a user's password
func (db *DB) ChangeUserPassword(userID int, newPassword string) error <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query := `UPDATE users SET password_hash = $1, updated_at = now() WHERE id = $2`
        _, err = db.Exec(query, string(hashedPassword), userID)
        return err</span>
}

// DeleteUser soft deletes a user account
func (db *DB) DeleteUser(userID int) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := db.Beginx()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Soft delete user
        _, err = tx.Exec(`UPDATE users SET is_active = false, updated_at = now() WHERE id = $1`, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete all user sessions
        <span class="cov0" title="0">_, err = tx.Exec(`DELETE FROM user_sessions WHERE user_id = $1`, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete old API tokens
        <span class="cov0" title="0">_, err = tx.Exec(`DELETE FROM tokens WHERE user_id = $1`, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

// CleanupExpiredSessions removes expired sessions from the database
func (db *DB) CleanupExpiredSessions() error <span class="cov0" title="0">{
        query := `DELETE FROM user_sessions WHERE expires_at &lt;= now()`
        _, err := db.Exec(query)
        return err
}</span>

// ListUsers returns all active users (admin function)
func (db *DB) ListUsers(limit, offset int) ([]User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, role, created_at, updated_at, last_login, is_active
                FROM users 
                WHERE is_active = true
                ORDER BY created_at DESC
                LIMIT $1 OFFSET $2`

        var users []User
        err := db.Select(&amp;users, query, limit, offset)
        return users, err
}</span>

// HasPermission checks if a user role has permission for a specific action
func (r UserRole) HasPermission(action string) bool <span class="cov0" title="0">{
        // Root has access to everything
        if r == RoleRoot </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">switch action </span>{
        case "read":<span class="cov0" title="0">
                return r == RoleUser || r == RolePublisher || r == RoleAdmin</span>
        case "publish":<span class="cov0" title="0">
                return r == RolePublisher || r == RoleAdmin</span>
        case "admin":<span class="cov0" title="0">
                return r == RoleAdmin</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package manifest

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "regexp"
)

// ProjectManifest represents the rulestack.json file in project mode (dependency management)
type ProjectManifest struct {
        Version      string            `json:"version"`
        Dependencies map[string]string `json:"dependencies"`
}

// PackageManifest represents a single ruleset package entry
type PackageManifest struct {
        Name        string   `json:"name"`
        Version     string   `json:"version"`
        Description string   `json:"description,omitempty"`
        Targets     []string `json:"targets,omitempty"`
        Tags        []string `json:"tags,omitempty"`
        Files       []string `json:"files"`
        License     string   `json:"license,omitempty"`
}

// PackageManifestFile represents the entire rulestack.json file in package mode (array of packages)
type PackageManifestFile []PackageManifest

// Legacy Manifest type for backward compatibility
type Manifest = PackageManifest
type ManifestFile = PackageManifestFile

var (
        ErrInvalidManifest = errors.New("invalid manifest")
        ErrInvalidName     = errors.New("invalid package name")
        ErrInvalidVersion  = errors.New("invalid version")
        ErrEmptyManifest   = errors.New("manifest file cannot be empty")
)

// nameRegex matches valid package names (with or without scope)
var nameRegex = regexp.MustCompile(`^(@[a-z0-9][a-z0-9\-_]*\/)?[a-z0-9][a-z0-9\-_]*$`)

// versionRegex matches semantic versions
var versionRegex = regexp.MustCompile(`^\d+\.\d+\.\d+(-[a-zA-Z0-9\-]+)?(\+[a-zA-Z0-9\-]+)?$`)

// PROJECT MANIFEST FUNCTIONS

// LoadProjectManifest reads and validates a project manifest from file
func LoadProjectManifest(path string) (*ProjectManifest, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read project manifest: %w", err)
        }</span>

        <span class="cov0" title="0">var manifest ProjectManifest
        if err := json.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse project manifest JSON: %w", err)
        }</span>

        <span class="cov0" title="0">if err := manifest.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid project manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;manifest, nil</span>
}

// SaveProjectManifest writes a project manifest to file
func SaveProjectManifest(path string, manifest *ProjectManifest) error <span class="cov0" title="0">{
        if err := manifest.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid project manifest: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(manifest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal project manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(path, data, 0o644)</span>
}

// Validate checks if the project manifest is valid
func (pm *ProjectManifest) Validate() error <span class="cov0" title="0">{
        if pm.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: version is required", ErrInvalidManifest)
        }</span>

        <span class="cov0" title="0">if !versionRegex.MatchString(pm.Version) </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: version must be semantic version (x.y.z)", ErrInvalidVersion)
        }</span>

        <span class="cov0" title="0">if pm.Dependencies == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: dependencies field is required (can be empty object)", ErrInvalidManifest)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateProjectManifest creates a new project manifest with default values
func CreateProjectManifest() *ProjectManifest <span class="cov0" title="0">{
        return &amp;ProjectManifest{
                Version:      "1.0.0",
                Dependencies: make(map[string]string),
        }
}</span>

// PACKAGE MANIFEST FUNCTIONS

// LoadPackageManifests reads and validates all package manifests from file
func LoadPackageManifests(path string) (PackageManifestFile, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read package manifests: %w", err)
        }</span>

        <span class="cov8" title="1">var manifests PackageManifestFile
        if err := json.Unmarshal(data, &amp;manifests); err != nil </span><span class="cov8" title="1">{
                // Try to parse as single manifest for backward compatibility
                var singleManifest PackageManifest
                if err := json.Unmarshal(data, &amp;singleManifest); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse package manifest JSON: %w", err)
                }</span>
                <span class="cov8" title="1">manifests = PackageManifestFile{singleManifest}</span>
        }

        <span class="cov8" title="1">if len(manifests) == 0 </span><span class="cov0" title="0">{
                return nil, ErrEmptyManifest
        }</span>

        // Validate all manifests
        <span class="cov8" title="1">for i, manifest := range manifests </span><span class="cov8" title="1">{
                if err := manifest.Validate(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("package manifest[%d]: %w", i, err)
                }</span>
        }

        <span class="cov8" title="1">return manifests, nil</span>
}

// LoadFirstPackageManifest reads the first package manifest from file
func LoadFirstPackageManifest(path string) (*PackageManifest, error) <span class="cov8" title="1">{
        manifests, err := LoadPackageManifests(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(manifests) == 0 </span><span class="cov0" title="0">{
                return nil, ErrEmptyManifest
        }</span>

        <span class="cov8" title="1">return &amp;manifests[0], nil</span>
}

// SavePackageManifests writes all package manifests to file
func SavePackageManifests(path string, manifests PackageManifestFile) error <span class="cov8" title="1">{
        if len(manifests) == 0 </span><span class="cov0" title="0">{
                return ErrEmptyManifest
        }</span>

        // Validate all manifests
        <span class="cov8" title="1">for i, manifest := range manifests </span><span class="cov8" title="1">{
                if err := manifest.Validate(); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("package manifest[%d]: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">data, err := json.MarshalIndent(manifests, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal package manifests: %w", err)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(path, data, 0o644)</span>
}

// SavePackageManifest writes a single package manifest to file as an array
func SavePackageManifest(path string, manifest *PackageManifest) error <span class="cov8" title="1">{
        manifests := PackageManifestFile{*manifest}
        return SavePackageManifests(path, manifests)
}</span>

// SaveSinglePackageManifest writes a single package manifest as an object (not array)
func SaveSinglePackageManifest(path string, manifest *PackageManifest) error <span class="cov8" title="1">{
        // Validate the manifest
        if err := manifest.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("package manifest validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">data, err := json.MarshalIndent(manifest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal package manifest: %w", err)
        }</span>

        <span class="cov8" title="1">return os.WriteFile(path, data, 0o644)</span>
}

// Validate checks if the package manifest is valid
func (pm *PackageManifest) Validate() error <span class="cov8" title="1">{
        if pm.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: name is required", ErrInvalidManifest)
        }</span>

        <span class="cov8" title="1">if !nameRegex.MatchString(pm.Name) </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: name must match pattern %s", ErrInvalidName, nameRegex.String())
        }</span>

        <span class="cov8" title="1">if pm.Version == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: version is required", ErrInvalidManifest)
        }</span>

        <span class="cov8" title="1">if !versionRegex.MatchString(pm.Version) </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: version must be semantic version (x.y.z)", ErrInvalidVersion)
        }</span>

        <span class="cov8" title="1">if len(pm.Files) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: files array cannot be empty", ErrInvalidManifest)
        }</span>

        // Validate targets
        <span class="cov8" title="1">validTargets := map[string]bool{
                "cursor":      true,
                "claude-code": true,
                "windsurf":    true,
                "copilot":     true,
        }

        for _, target := range pm.Targets </span><span class="cov8" title="1">{
                if !validTargets[target] </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: invalid target '%s'", ErrInvalidManifest, target)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetPackageName returns the package name (no scope support)
func (pm *PackageManifest) GetPackageName() string <span class="cov8" title="1">{
        return pm.Name
}</span>

// CreateSamplePackageManifest creates a sample package manifest for initialization
func CreateSamplePackageManifest() *PackageManifest <span class="cov8" title="1">{
        return &amp;PackageManifest{
                Name:        "example-rules",
                Version:     "0.1.0",
                Description: "Example AI ruleset",
                Targets:     []string{"cursor"},
                Tags:        []string{"example", "starter"},
                Files:       []string{"*.md"},
                License:     "MIT",
        }
}</span>

// CreateSamplePackageManifestFile creates a sample package manifest file with one entry
func CreateSamplePackageManifestFile() PackageManifestFile <span class="cov0" title="0">{
        return PackageManifestFile{*CreateSamplePackageManifest()}
}</span>

// LEGACY FUNCTIONS FOR BACKWARD COMPATIBILITY

// Load reads and validates a manifest from file (legacy function)
func Load(path string) (*Manifest, error) <span class="cov8" title="1">{
        return LoadFirstPackageManifest(path)
}</span>

// LoadAll reads and validates all manifests from file (legacy function)
func LoadAll(path string) (ManifestFile, error) <span class="cov0" title="0">{
        return LoadPackageManifests(path)
}</span>

// Save writes manifest to file as an array with single entry (legacy method)
func (m *Manifest) Save(path string) error <span class="cov8" title="1">{
        return SavePackageManifest(path, m)
}</span>

// Save writes all manifests to file (legacy method)
func (mf ManifestFile) Save(path string) error <span class="cov0" title="0">{
        return SavePackageManifests(path, mf)
}</span>

// CreateSample creates a sample manifest for initialization (legacy function)
func CreateSample() *Manifest <span class="cov8" title="1">{
        return CreateSamplePackageManifest()
}</span>

// CreateSampleFile creates a sample manifest file with one entry (legacy function)
func CreateSampleFile() ManifestFile <span class="cov0" title="0">{
        return CreateSamplePackageManifestFile()
}</span>

// UTILITY FUNCTIONS

// IsProjectManifest checks if a rulestack.json file contains a project manifest
func IsProjectManifest(path string) bool <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Try to parse as project manifest
        <span class="cov0" title="0">var pm ProjectManifest
        if err := json.Unmarshal(data, &amp;pm); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if it has project manifest fields and lacks package manifest fields
        <span class="cov0" title="0">return pm.Dependencies != nil</span>
}

// IsPackageManifest checks if a rulestack.json file contains package manifests
func IsPackageManifest(path string) bool <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Try to parse as package manifest array
        <span class="cov0" title="0">var pmf PackageManifestFile
        if err := json.Unmarshal(data, &amp;pmf); err != nil </span><span class="cov0" title="0">{
                // Try single package manifest
                var pm PackageManifest
                if err := json.Unmarshal(data, &amp;pm); err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return pm.Name != ""</span> // Package manifests must have names
        }

        <span class="cov0" title="0">return len(pmf) &gt; 0 &amp;&amp; pmf[0].Name != ""</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package pkg

import (
        "archive/tar"
        "compress/gzip"
        "crypto/sha256"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "rulestack/internal/security"

        "github.com/bmatcuk/doublestar/v4"
)

// ArchiveInfo contains information about a created archive
type ArchiveInfo struct {
        Path      string
        SHA256    string
        SizeBytes int64
}

// Pack creates a tar.gz archive from file patterns
func Pack(patterns []string, outputPath string) (*ArchiveInfo, error) <span class="cov8" title="1">{
        // Collect all files matching the patterns
        var files []string
        seen := make(map[string]bool)

        for _, pattern := range patterns </span><span class="cov8" title="1">{
                matches, err := doublestar.FilepathGlob(pattern)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to match pattern %s: %w", pattern, err)
                }</span>

                <span class="cov8" title="1">for _, match := range matches </span><span class="cov8" title="1">{
                        // Skip directories
                        if info, err := os.Stat(match); err != nil || info.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Clean path and avoid duplicates
                        <span class="cov8" title="1">cleanPath := filepath.Clean(match)
                        if !seen[cleanPath] </span><span class="cov8" title="1">{
                                files = append(files, cleanPath)
                                seen[cleanPath] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(files) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no files matched the specified patterns")
        }</span>

        // Create output file
        <span class="cov8" title="1">outFile, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create archive file: %w", err)
        }</span>
        <span class="cov8" title="1">defer outFile.Close()

        // Create hash writer
        hasher := sha256.New()
        multiWriter := io.MultiWriter(outFile, hasher)

        // Create gzip writer
        gzWriter := gzip.NewWriter(multiWriter)
        defer gzWriter.Close()

        // Create tar writer
        tarWriter := tar.NewWriter(gzWriter)
        defer tarWriter.Close()

        var totalSize int64

        // Add each file to the archive
        for _, filePath := range files </span><span class="cov8" title="1">{
                if err := addFileToArchive(tarWriter, filePath); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add file %s: %w", filePath, err)
                }</span>

                <span class="cov8" title="1">if info, err := os.Stat(filePath); err == nil </span><span class="cov8" title="1">{
                        totalSize += info.Size()
                }</span>
        }

        // Close writers to flush data before calculating hash
        <span class="cov8" title="1">tarWriter.Close()
        gzWriter.Close()
        outFile.Close()

        // Get final archive info
        info, err := os.Stat(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat archive: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ArchiveInfo{
                Path:      outputPath,
                SHA256:    fmt.Sprintf("%x", hasher.Sum(nil)),
                SizeBytes: info.Size(),
        }, nil</span>
}

// addFileToArchive adds a single file to the tar archive
func addFileToArchive(tarWriter *tar.Writer, filePath string) error <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        info, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create tar header
        <span class="cov8" title="1">header, err := tar.FileInfoHeader(info, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use forward slashes in archive
        <span class="cov8" title="1">header.Name = filepath.ToSlash(filePath)

        // Write header
        if err := tarWriter.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write file content
        <span class="cov8" title="1">_, err = io.Copy(tarWriter, file)
        return err</span>
}

// Unpack extracts a tar.gz archive to a destination directory with security validation
func Unpack(archivePath string, destDir string) error <span class="cov8" title="1">{
        // First, validate the archive for security
        validator := security.NewPackageValidator(nil)
        if err := validator.ValidateArchive(archivePath, destDir); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("security validation failed: %w", err)
        }</span>

        // If validation passes, proceed with extraction
        <span class="cov8" title="1">return UnpackValidated(archivePath, destDir)</span>
}

// UnpackValidated extracts a pre-validated archive (internal use)
func UnpackValidated(archivePath string, destDir string) error <span class="cov8" title="1">{
        file, err := os.Open(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open archive: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Create gzip reader
        gzReader, err := gzip.NewReader(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create gzip reader: %w", err)
        }</span>
        <span class="cov8" title="1">defer gzReader.Close()

        // Create tar reader
        tarReader := tar.NewReader(gzReader)

        // Extract files
        for </span><span class="cov8" title="1">{
                header, err := tarReader.Next()
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read tar header: %w", err)
                }</span>

                <span class="cov8" title="1">if err := extractFileSecure(tarReader, header, destDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to extract file %s: %w", header.Name, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// extractFileSecure extracts a single file from tar archive with enhanced security
func extractFileSecure(tarReader *tar.Reader, header *tar.Header, destDir string) error <span class="cov8" title="1">{
        // Validate file path (redundant with validator, but defense in depth)
        if err := validateExtractionPath(header.Name, destDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">destPath := filepath.Join(destDir, header.Name)

        // Handle directories
        if header.Typeflag == tar.TypeDir </span><span class="cov0" title="0">{
                return os.MkdirAll(destPath, 0o755)
        }</span>

        // Only handle regular files (symlinks and other types rejected by validator)
        <span class="cov8" title="1">if header.Typeflag != tar.TypeReg </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported file type: %c", header.Typeflag)
        }</span>

        // Create directory if needed
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(destPath), 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create file with safe permissions
        <span class="cov8" title="1">outFile, err := os.OpenFile(destPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer outFile.Close()

        // Copy file content with size limit (defense in depth)
        _, err = io.CopyN(outFile, tarReader, security.MaxFileSize)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateExtractionPath validates the extraction path for security
func validateExtractionPath(filePath, destDir string) error <span class="cov8" title="1">{
        // Reject absolute paths
        if filepath.IsAbs(filePath) </span><span class="cov0" title="0">{
                return fmt.Errorf("absolute paths not allowed: %s", filePath)
        }</span>

        // Reject paths with .. segments
        <span class="cov8" title="1">if strings.Contains(filePath, "..") </span><span class="cov0" title="0">{
                return fmt.Errorf("path traversal attempt: %s", filePath)
        }</span>

        // Ensure the final path is within the destination directory
        <span class="cov8" title="1">destPath := filepath.Join(destDir, filePath)
        cleanDest := filepath.Clean(destPath)
        cleanDestDir := filepath.Clean(destDir)

        if !strings.HasPrefix(cleanDest, cleanDestDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("path escapes destination directory: %s", filePath)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// extractFile extracts a single file from tar archive (legacy function for compatibility)
func extractFile(tarReader *tar.Reader, header *tar.Header, destDir string) error <span class="cov0" title="0">{
        return extractFileSecure(tarReader, header, destDir)
}</span>

// CalculateSHA256 calculates SHA256 hash of a file
func CalculateSHA256(filePath string) (string, error) <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hasher := sha256.New()
        if _, err := io.Copy(hasher, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%x", hasher.Sum(nil)), nil</span>
}

// PackFromDirectory creates a tar.gz archive from all files in a directory
func PackFromDirectory(sourceDir string, outputPath string) (*ArchiveInfo, error) <span class="cov0" title="0">{
        // Walk the directory and collect all files
        var files []string
        err := filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Skip getting relative path as we don't need it here

                <span class="cov0" title="0">files = append(files, path)
                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to walk directory %s: %w", sourceDir, err)
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no files found in directory: %s", sourceDir)
        }</span>

        // Use the existing Pack function but we need to handle the paths differently
        // Let's create the archive manually
        <span class="cov0" title="0">return packFiles(files, sourceDir, outputPath)</span>
}

// packFiles creates archive from specific files with a base directory
func packFiles(filePaths []string, baseDir string, outputPath string) (*ArchiveInfo, error) <span class="cov0" title="0">{
        // Create output file
        outputFile, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer outputFile.Close()

        // Create gzip writer
        gzWriter := gzip.NewWriter(outputFile)
        defer gzWriter.Close()

        // Create tar writer
        tarWriter := tar.NewWriter(gzWriter)
        defer tarWriter.Close()

        // Hash calculator for final SHA256
        hasher := sha256.New()
        multiWriter := io.MultiWriter(outputFile, hasher)

        // Reset and create new writers with hash calculation
        outputFile.Seek(0, 0)
        outputFile.Truncate(0)

        gzWriter = gzip.NewWriter(multiWriter)
        defer gzWriter.Close()

        tarWriter = tar.NewWriter(gzWriter)
        defer tarWriter.Close()

        // Add files to archive
        for _, filePath := range filePaths </span><span class="cov0" title="0">{
                // Get relative path from base directory
                relPath, err := filepath.Rel(baseDir, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get relative path for %s: %w", filePath, err)
                }</span>

                // Open file
                <span class="cov0" title="0">file, err := os.Open(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open file %s: %w", filePath, err)
                }</span>

                // Get file info
                <span class="cov0" title="0">fileInfo, err := file.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        file.Close()
                        return nil, fmt.Errorf("failed to stat file %s: %w", filePath, err)
                }</span>

                // Create tar header
                <span class="cov0" title="0">header := &amp;tar.Header{
                        Name:    filepath.ToSlash(relPath), // Use forward slashes for cross-platform compatibility
                        Size:    fileInfo.Size(),
                        Mode:    int64(fileInfo.Mode()),
                        ModTime: fileInfo.ModTime(),
                }

                // Write header
                if err := tarWriter.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                        file.Close()
                        return nil, fmt.Errorf("failed to write tar header for %s: %w", filePath, err)
                }</span>

                // Copy file content
                <span class="cov0" title="0">if _, err := io.Copy(tarWriter, file); err != nil </span><span class="cov0" title="0">{
                        file.Close()
                        return nil, fmt.Errorf("failed to copy file content for %s: %w", filePath, err)
                }</span>

                <span class="cov0" title="0">file.Close()</span>
        }

        // Close writers to flush data
        <span class="cov0" title="0">tarWriter.Close()
        gzWriter.Close()

        // Get file size
        stat, err := outputFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat output file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ArchiveInfo{
                Path:      outputPath,
                SHA256:    fmt.Sprintf("%x", hasher.Sum(nil)),
                SizeBytes: stat.Size(),
        }, nil</span>
}

// ExtractManifest extracts only the rulestack.json manifest from an archive
func ExtractManifest(archivePath string) ([]byte, error) <span class="cov0" title="0">{
        file, err := os.Open(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open archive: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Create gzip reader
        gzReader, err := gzip.NewReader(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create gzip reader: %w", err)
        }</span>
        <span class="cov0" title="0">defer gzReader.Close()

        // Create tar reader
        tarReader := tar.NewReader(gzReader)

        // Look for rulestack.json file
        for </span><span class="cov0" title="0">{
                header, err := tarReader.Next()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read tar header: %w", err)
                }</span>

                // Check if this is the manifest file
                <span class="cov0" title="0">if header.Name == "rulestack.json" || strings.HasSuffix(header.Name, "/rulestack.json") </span><span class="cov0" title="0">{
                        // Read the manifest content
                        manifestData, err := io.ReadAll(tarReader)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to read manifest from archive: %w", err)
                        }</span>
                        <span class="cov0" title="0">return manifestData, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no manifest (rulestack.json) found in archive")</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package pkg

import (
        "encoding/json"
        "os"
)

// Lockfile represents the rfh.lock file format
type Lockfile struct {
        Registry string                   `json:"registry"`
        Packages map[string]LockfileEntry `json:"packages"`
}

// LockfileEntry represents a single package in the lockfile
type LockfileEntry struct {
        Version     string   `json:"version"`
        SHA256      string   `json:"sha256"`
        Targets     []string `json:"targets"`
        InstallPath string   `json:"install_path"`
        Registry    string   `json:"registry,omitempty"`
}

// LoadLockfile reads and parses a lockfile
func LoadLockfile(path string) (*Lockfile, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Return empty lockfile if doesn't exist
                return &amp;Lockfile{
                        Packages: make(map[string]LockfileEntry),
                }, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var lockfile Lockfile
        if err := json.Unmarshal(data, &amp;lockfile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if lockfile.Packages == nil </span><span class="cov0" title="0">{
                lockfile.Packages = make(map[string]LockfileEntry)
        }</span>

        <span class="cov0" title="0">return &amp;lockfile, nil</span>
}

// SaveLockfile writes the lockfile to disk
func (l *Lockfile) SaveLockfile(path string) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(l, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(path, data, 0o644)</span>
}

// AddPackage adds or updates a package in the lockfile
func (l *Lockfile) AddPackage(name string, entry LockfileEntry) <span class="cov0" title="0">{
        if l.Packages == nil </span><span class="cov0" title="0">{
                l.Packages = make(map[string]LockfileEntry)
        }</span>
        <span class="cov0" title="0">l.Packages[name] = entry</span>
}

// RemovePackage removes a package from the lockfile
func (l *Lockfile) RemovePackage(name string) <span class="cov0" title="0">{
        if l.Packages != nil </span><span class="cov0" title="0">{
                delete(l.Packages, name)
        }</span>
}

// HasPackage checks if a package exists in the lockfile
func (l *Lockfile) HasPackage(name string) bool <span class="cov0" title="0">{
        if l.Packages == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, exists := l.Packages[name]
        return exists</span>
}

// GetPackage gets a package from the lockfile
func (l *Lockfile) GetPackage(name string) (LockfileEntry, bool) <span class="cov0" title="0">{
        if l.Packages == nil </span><span class="cov0" title="0">{
                return LockfileEntry{}, false
        }</span>
        <span class="cov0" title="0">entry, exists := l.Packages[name]
        return entry, exists</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package security

import (
        "archive/tar"
        "bytes"
        "compress/gzip"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "unicode/utf8"

        "github.com/microcosm-cc/bluemonday"
)

const (
        // Security limits
        MaxFileSize        = 1024 * 1024      // 1MB per file
        MaxTotalSize       = 10 * 1024 * 1024 // 10MB total uncompressed
        MaxFilesPerArchive = 100              // Maximum number of files
)

// SecurityConfig contains security validation settings
type SecurityConfig struct {
        AllowedExtensions []string
        MaxFileSize       int64
        MaxTotalSize      int64
        MaxFiles          int
        RequireUTF8       bool
        SanitizeMarkdown  bool
}

// DefaultSecurityConfig returns the default security configuration
func DefaultSecurityConfig() *SecurityConfig <span class="cov8" title="1">{
        return &amp;SecurityConfig{
                AllowedExtensions: []string{".md", ".txt", ".json", ".mdc"},
                MaxFileSize:       MaxFileSize,
                MaxTotalSize:      MaxTotalSize,
                MaxFiles:          MaxFilesPerArchive,
                RequireUTF8:       true,
                SanitizeMarkdown:  true,
        }
}</span>

// PackageValidator handles security validation of packages
type PackageValidator struct {
        config *SecurityConfig
        policy *bluemonday.Policy
}

// NewPackageValidator creates a new package validator
func NewPackageValidator(config *SecurityConfig) *PackageValidator <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultSecurityConfig()
        }</span>

        // Create a strict markdown policy - only allow safe markdown elements
        <span class="cov8" title="1">policy := bluemonday.NewPolicy()

        // Allow basic markdown formatting
        policy.AllowElements("h1", "h2", "h3", "h4", "h5", "h6", "p", "br", "hr")
        policy.AllowElements("strong", "b", "em", "i", "code", "pre", "blockquote")
        policy.AllowElements("ul", "ol", "li", "dl", "dt", "dd")
        policy.AllowElements("table", "thead", "tbody", "tr", "th", "td")

        // Allow links but sanitize them
        policy.AllowAttrs("href").OnElements("a")
        policy.RequireNoReferrerOnLinks(true)
        policy.RequireNoFollowOnLinks(true)
        policy.AddTargetBlankToFullyQualifiedLinks(true)

        // Forbid dangerous elements - no scripts, objects, embeds, etc.
        // This is already the default with a strict policy

        return &amp;PackageValidator{
                config: config,
                policy: policy,
        }</span>
}

// ValidateArchive validates the security of a package archive
func (v *PackageValidator) ValidateArchive(archivePath, extractDir string) error <span class="cov8" title="1">{
        file, err := os.Open(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open archive: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        gzReader, err := gzip.NewReader(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create gzip reader: %w", err)
        }</span>
        <span class="cov8" title="1">defer gzReader.Close()

        tarReader := tar.NewReader(gzReader)

        var totalSize int64
        var fileCount int

        for </span><span class="cov8" title="1">{
                header, err := tarReader.Next()
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read tar entry: %w", err)
                }</span>

                <span class="cov8" title="1">fileCount++
                if fileCount &gt; v.config.MaxFiles </span><span class="cov8" title="1">{
                        return fmt.Errorf("archive contains too many files (max %d)", v.config.MaxFiles)
                }</span>

                // Validate file path security
                <span class="cov8" title="1">if err := v.validateFilePath(header.Name, extractDir); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unsafe file path '%s': %w", header.Name, err)
                }</span>

                // Validate file type
                <span class="cov8" title="1">if err := v.validateFileType(header.Name); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid file type '%s': %w", header.Name, err)
                }</span>

                // Check file size
                <span class="cov8" title="1">if header.Size &gt; v.config.MaxFileSize </span><span class="cov8" title="1">{
                        return fmt.Errorf("file '%s' too large (%d bytes, max %d)",
                                header.Name, header.Size, v.config.MaxFileSize)
                }</span>

                <span class="cov8" title="1">totalSize += header.Size
                if totalSize &gt; v.config.MaxTotalSize </span><span class="cov0" title="0">{
                        return fmt.Errorf("archive too large (%d bytes, max %d)",
                                totalSize, v.config.MaxTotalSize)
                }</span>

                // Validate file content for regular files
                <span class="cov8" title="1">if header.Typeflag == tar.TypeReg </span><span class="cov8" title="1">{
                        if err := v.validateFileContent(tarReader, header); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid content in '%s': %w", header.Name, err)
                        }</span>
                }

                // Reject symlinks and other special file types
                <span class="cov8" title="1">if header.Typeflag != tar.TypeReg &amp;&amp; header.Typeflag != tar.TypeDir </span><span class="cov0" title="0">{
                        return fmt.Errorf("unsupported file type for '%s': %c", header.Name, header.Typeflag)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateFilePath checks for path traversal and other path-based attacks
func (v *PackageValidator) validateFilePath(filePath, extractDir string) error <span class="cov8" title="1">{
        // Reject absolute paths (check both Unix and Windows style)
        if filepath.IsAbs(filePath) || strings.HasPrefix(filePath, "/") || strings.HasPrefix(filePath, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("absolute paths not allowed")
        }</span>

        // Reject paths with .. segments (path traversal)
        <span class="cov8" title="1">if strings.Contains(filePath, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("path traversal attempt detected")
        }</span>

        // Ensure the final path is within the extract directory
        <span class="cov8" title="1">fullPath := filepath.Join(extractDir, filePath)
        if !strings.HasPrefix(filepath.Clean(fullPath), filepath.Clean(extractDir)) </span><span class="cov0" title="0">{
                return fmt.Errorf("path escapes extraction directory")
        }</span>

        // Reject paths with control characters or other dangerous characters
        <span class="cov8" title="1">for _, r := range filePath </span><span class="cov8" title="1">{
                if r &lt; 32 || r == 127 </span><span class="cov0" title="0">{ // Control characters
                        return fmt.Errorf("control characters in path not allowed")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateFileType checks if the file extension is allowed
func (v *PackageValidator) validateFileType(filePath string) error <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filePath))

        // Allow directories (no extension)
        if ext == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, allowed := range v.config.AllowedExtensions </span><span class="cov8" title="1">{
                if ext == allowed </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("file extension '%s' not allowed", ext)</span>
}

// validateFileContent validates the content of a file
func (v *PackageValidator) validateFileContent(reader io.Reader, header *tar.Header) error <span class="cov8" title="1">{
        // Read file content
        content, err := io.ReadAll(io.LimitReader(reader, v.config.MaxFileSize))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file content: %w", err)
        }</span>

        // Check for NUL bytes
        <span class="cov8" title="1">if bytes.Contains(content, []byte{0}) </span><span class="cov8" title="1">{
                return fmt.Errorf("file contains NUL bytes")
        }</span>

        // Check for executable headers
        <span class="cov8" title="1">if err := v.checkExecutableHeaders(content, header.Name); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate UTF-8 encoding for text files
        <span class="cov8" title="1">if v.config.RequireUTF8 &amp;&amp; isTextFile(header.Name) </span><span class="cov8" title="1">{
                if !utf8.Valid(content) </span><span class="cov8" title="1">{
                        return fmt.Errorf("file is not valid UTF-8")
                }</span>
        }

        // Sanitize markdown content
        <span class="cov8" title="1">if v.config.SanitizeMarkdown &amp;&amp; strings.HasSuffix(strings.ToLower(header.Name), ".md") </span><span class="cov8" title="1">{
                if err := v.validateMarkdownContent(content); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("markdown validation failed: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// checkExecutableHeaders checks for executable file headers
func (v *PackageValidator) checkExecutableHeaders(content []byte, filename string) error <span class="cov8" title="1">{
        if len(content) &lt; 4 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check for common executable signatures
        <span class="cov8" title="1">signatures := map[string][]byte{
                "ELF":       {0x7F, 0x45, 0x4C, 0x46}, // ELF executables
                "PE":        {0x4D, 0x5A},             // PE executables (MZ header)
                "Mach-O 32": {0xFE, 0xED, 0xFA, 0xCE}, // Mach-O 32-bit
                "Mach-O 64": {0xFE, 0xED, 0xFA, 0xCF}, // Mach-O 64-bit
                "Java":      {0xCA, 0xFE, 0xBA, 0xBE}, // Java class files
                "Shebang":   {0x23, 0x21},             // #! scripts
        }

        for sigName, sig := range signatures </span><span class="cov8" title="1">{
                if len(content) &gt;= len(sig) &amp;&amp; bytes.HasPrefix(content, sig) </span><span class="cov8" title="1">{
                        return fmt.Errorf("executable file detected (%s signature)", sigName)
                }</span>
        }

        // Check for script extensions
        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(filename))
        scriptExts := []string{".sh", ".bat", ".cmd", ".ps1", ".py", ".rb", ".pl", ".js", ".exe", ".dll", ".so", ".dylib"}
        for _, scriptExt := range scriptExts </span><span class="cov8" title="1">{
                if ext == scriptExt </span><span class="cov0" title="0">{
                        return fmt.Errorf("executable/script file extension not allowed: %s", ext)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateMarkdownContent validates markdown content using bluemonday
func (v *PackageValidator) validateMarkdownContent(content []byte) error <span class="cov8" title="1">{
        // Check if the content becomes significantly different after sanitization
        original := string(content)
        sanitized := v.policy.Sanitize(original)

        // If the sanitized version is very different, it likely contained dangerous content
        originalLines := strings.Split(original, "\n")
        sanitizedLines := strings.Split(sanitized, "\n")

        // Allow some difference due to HTML cleanup, but reject major changes
        if len(sanitizedLines) &lt; len(originalLines)/2 </span><span class="cov0" title="0">{
                return fmt.Errorf("markdown content contains potentially dangerous elements")
        }</span>

        // Check for suspicious patterns in the original content
        <span class="cov8" title="1">suspiciousPatterns := []string{
                "&lt;script",
                "&lt;iframe",
                "&lt;object",
                "&lt;embed",
                "&lt;applet",
                "javascript:",
                "data:",
                "vbscript:",
                "onload=",
                "onerror=",
                "onclick=",
        }

        lowerContent := strings.ToLower(original)
        for _, pattern := range suspiciousPatterns </span><span class="cov8" title="1">{
                if strings.Contains(lowerContent, pattern) </span><span class="cov8" title="1">{
                        return fmt.Errorf("markdown content contains suspicious pattern: %s", pattern)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isTextFile determines if a file should be treated as text based on extension
func isTextFile(filename string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filename))
        textExts := []string{".md", ".txt", ".json", ".yaml", ".yml", ".toml", ".ini", ".mdc"}

        for _, textExt := range textExts </span><span class="cov8" title="1">{
                if ext == textExt </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package version

import (
        "fmt"
        "strconv"
        "strings"
)

// Version represents a semantic version
type Version struct {
        Major int
        Minor int
        Patch int
        Pre   string // Pre-release identifier (e.g., "alpha", "beta.1")
        Build string // Build metadata (e.g., "20230101.abcd123")
}

// Parse parses a semantic version string into a Version struct
func Parse(versionStr string) (*Version, error) <span class="cov8" title="1">{
        if versionStr == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("version cannot be empty")
        }</span>

        // Handle build metadata (+)
        <span class="cov8" title="1">var buildMeta string
        if idx := strings.Index(versionStr, "+"); idx != -1 </span><span class="cov8" title="1">{
                buildMeta = versionStr[idx+1:]
                versionStr = versionStr[:idx]
        }</span>

        // Handle pre-release (-)
        <span class="cov8" title="1">var preRelease string
        if idx := strings.Index(versionStr, "-"); idx != -1 </span><span class="cov8" title="1">{
                preRelease = versionStr[idx+1:]
                versionStr = versionStr[:idx]
        }</span>

        // Parse major.minor.patch
        <span class="cov8" title="1">parts := strings.Split(versionStr, ".")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid version format: expected x.y.z, got %s", versionStr)
        }</span>

        <span class="cov8" title="1">major, err := strconv.Atoi(parts[0])
        if err != nil || major &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid major version: %s", parts[0])
        }</span>

        <span class="cov8" title="1">minor, err := strconv.Atoi(parts[1])
        if err != nil || minor &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid minor version: %s", parts[1])
        }</span>

        <span class="cov8" title="1">patch, err := strconv.Atoi(parts[2])
        if err != nil || patch &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid patch version: %s", parts[2])
        }</span>

        <span class="cov8" title="1">return &amp;Version{
                Major: major,
                Minor: minor,
                Patch: patch,
                Pre:   preRelease,
                Build: buildMeta,
        }, nil</span>
}

// String returns the string representation of the version
func (v *Version) String() string <span class="cov8" title="1">{
        result := fmt.Sprintf("%d.%d.%d", v.Major, v.Minor, v.Patch)

        if v.Pre != "" </span><span class="cov8" title="1">{
                result += "-" + v.Pre
        }</span>

        <span class="cov8" title="1">if v.Build != "" </span><span class="cov8" title="1">{
                result += "+" + v.Build
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Compare compares two versions and returns:
// -1 if v &lt; other
//
//        0 if v == other
//        1 if v &gt; other
func (v *Version) Compare(other *Version) int <span class="cov8" title="1">{
        // Compare major.minor.patch
        if v.Major != other.Major </span><span class="cov8" title="1">{
                if v.Major &gt; other.Major </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return -1</span>
        }

        <span class="cov8" title="1">if v.Minor != other.Minor </span><span class="cov8" title="1">{
                if v.Minor &gt; other.Minor </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return -1</span>
        }

        <span class="cov8" title="1">if v.Patch != other.Patch </span><span class="cov8" title="1">{
                if v.Patch &gt; other.Patch </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return -1</span>
        }

        // Handle pre-release versions
        // Per semver: 1.0.0-alpha &lt; 1.0.0
        <span class="cov8" title="1">if v.Pre == "" &amp;&amp; other.Pre != "" </span><span class="cov8" title="1">{
                return 1 // Normal version &gt; pre-release
        }</span>
        <span class="cov8" title="1">if v.Pre != "" &amp;&amp; other.Pre == "" </span><span class="cov8" title="1">{
                return -1 // Pre-release &lt; normal version
        }</span>
        <span class="cov8" title="1">if v.Pre != "" &amp;&amp; other.Pre != "" </span><span class="cov8" title="1">{
                // Both are pre-releases, compare lexicographically
                if v.Pre &gt; other.Pre </span><span class="cov8" title="1">{
                        return 1
                }</span> else<span class="cov8" title="1"> if v.Pre &lt; other.Pre </span><span class="cov8" title="1">{
                        return -1
                }</span>
        }

        // Build metadata is ignored in precedence comparison
        <span class="cov8" title="1">return 0</span>
}

// IsGreaterThan returns true if v &gt; other
func (v *Version) IsGreaterThan(other *Version) bool <span class="cov8" title="1">{
        return v.Compare(other) &gt; 0
}</span>

// IsLessThan returns true if v &lt; other
func (v *Version) IsLessThan(other *Version) bool <span class="cov0" title="0">{
        return v.Compare(other) &lt; 0
}</span>

// IsEqual returns true if v == other (ignoring build metadata)
func (v *Version) IsEqual(other *Version) bool <span class="cov0" title="0">{
        return v.Compare(other) == 0
}</span>

// IncrementPatch returns a new version with patch incremented
func (v *Version) IncrementPatch() *Version <span class="cov8" title="1">{
        return &amp;Version{
                Major: v.Major,
                Minor: v.Minor,
                Patch: v.Patch + 1,
                // Clear pre-release and build when incrementing
                Pre:   "",
                Build: "",
        }
}</span>

// IncrementMinor returns a new version with minor incremented and patch reset
func (v *Version) IncrementMinor() *Version <span class="cov8" title="1">{
        return &amp;Version{
                Major: v.Major,
                Minor: v.Minor + 1,
                Patch: 0,
                Pre:   "",
                Build: "",
        }
}</span>

// IncrementMajor returns a new version with major incremented and minor/patch reset
func (v *Version) IncrementMajor() *Version <span class="cov8" title="1">{
        return &amp;Version{
                Major: v.Major + 1,
                Minor: 0,
                Patch: 0,
                Pre:   "",
                Build: "",
        }
}</span>

// CONVENIENCE FUNCTIONS FOR BACKWARD COMPATIBILITY

// ValidateVersionIncrease ensures newVersion is greater than currentVersion
// This is the function previously in pack_interactive.go
func ValidateVersionIncrease(currentVersion, newVersion string) error <span class="cov8" title="1">{
        current, err := Parse(currentVersion)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid current version %s: %w", currentVersion, err)
        }</span>

        <span class="cov8" title="1">new, err := Parse(newVersion)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid new version %s: %w", newVersion, err)
        }</span>

        <span class="cov8" title="1">if !new.IsGreaterThan(current) </span><span class="cov8" title="1">{
                return fmt.Errorf("new version %s must be greater than current version %s", newVersion, currentVersion)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IncrementPatchVersion increments the patch version (x.y.z -&gt; x.y.z+1)
// This is the function previously in pack_interactive.go
func IncrementPatchVersion(versionStr string) (string, error) <span class="cov8" title="1">{
        v, err := Parse(versionStr)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid version format: %w", err)
        }</span>

        <span class="cov8" title="1">return v.IncrementPatch().String(), nil</span>
}

// IncrementMinorVersion increments the minor version (x.y.z -&gt; x.y+1.0)
func IncrementMinorVersion(versionStr string) (string, error) <span class="cov8" title="1">{
        v, err := Parse(versionStr)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid version format: %w", err)
        }</span>

        <span class="cov8" title="1">return v.IncrementMinor().String(), nil</span>
}

// IncrementMajorVersion increments the major version (x.y.z -&gt; x+1.0.0)
func IncrementMajorVersion(versionStr string) (string, error) <span class="cov8" title="1">{
        v, err := Parse(versionStr)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid version format: %w", err)
        }</span>

        <span class="cov8" title="1">return v.IncrementMajor().String(), nil</span>
}

// CompareVersions compares two version strings and returns:
// -1 if version1 &lt; version2
//
//        0 if version1 == version2
//        1 if version1 &gt; version2
func CompareVersions(version1, version2 string) (int, error) <span class="cov8" title="1">{
        v1, err := Parse(version1)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid version1 %s: %w", version1, err)
        }</span>

        <span class="cov8" title="1">v2, err := Parse(version2)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid version2 %s: %w", version2, err)
        }</span>

        <span class="cov8" title="1">return v1.Compare(v2), nil</span>
}

// IsValidVersion checks if a string is a valid semantic version
func IsValidVersion(versionStr string) bool <span class="cov8" title="1">{
        _, err := Parse(versionStr)
        return err == nil
}</span>

// GetNextVersions returns suggested next versions for all increment types
func GetNextVersions(currentVersion string) (patch, minor, major string, err error) <span class="cov8" title="1">{
        v, err := Parse(currentVersion)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", "", fmt.Errorf("invalid version: %w", err)
        }</span>

        <span class="cov8" title="1">return v.IncrementPatch().String(),
                v.IncrementMinor().String(),
                v.IncrementMajor().String(),
                nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package main

import (
        "fmt"
        "log"

        _ "github.com/lib/pq"

        "rulestack/internal/config"
        "rulestack/internal/db"
)

func main() <span class="cov0" title="0">{
        // Load environment
        config.LoadEnvFile(".env")
        cfg := config.Load()

        // Connect to database
        database, err := db.Connect(cfg.DBURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to connect to database:", err)
        }</span>
        <span class="cov0" title="0">defer database.Close()

        fmt.Printf("✅ Database connection established\n")

        // Show setup instructions
        fmt.Printf("🚀 Setup complete! Next steps:\n")
        fmt.Printf("   1. Start API: go run ./cmd/api\n")
        fmt.Printf("   2. Add registry: ./rfh registry add local http://localhost:8080\n")
        fmt.Printf("   3. Authenticate: ./rfh auth login\n")
        fmt.Printf("   4. Initialize package: ./rfh init\n")
        fmt.Printf("   5. Pack and publish: ./rfh pack &amp;&amp; ./rfh publish\n")
        fmt.Printf("\n💡 Authentication now uses JWT tokens via 'rfh auth login'\n")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
